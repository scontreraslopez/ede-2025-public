# UP9: UML. COMPORTAMIENTO E INTERACCIÓN

## ÍNDICE

- [OBJETIVOS](#objetivos)
- [1. INTRODUCCIÓN](#1-introducción)
- [2. DIAGRAMAS DE SECUENCIA](#2-diagramas-de-secuencia)
  - [2.1. Propósito](#21-propósito)
  - [2.2. Elementos del diagrama](#22-elementos-del-diagrama)
  - [2.3. Fragmentos combinados](#23-fragmentos-combinados)
  - [2.4. Ejemplos de diagramas de secuencia](#24-ejemplos-de-diagramas-de-secuencia)
- [3. DIAGRAMAS DE COMUNICACIÓN](#3-diagramas-de-comunicación)
  - [3.1. Propósito](#31-propósito)
  - [3.2. Elementos del diagrama](#32-elementos-del-diagrama)
  - [3.3. Ejemplo de diagrama de comunicación](#33-ejemplo-de-diagrama-de-comunicación)
  - [3.4. Uso práctico y alternativas](#34-uso-práctico-y-alternativas)
- [4. DIAGRAMAS DE ACTIVIDADES](#4-diagramas-de-actividades)
  - [4.1. Propósito](#41-propósito)
  - [4.2. Elementos del diagrama](#42-elementos-del-diagrama)
  - [4.3. Calles (Swimlanes)](#43-calles-swimlanes)
  - [4.4. Ejemplos de diagramas de actividades](#44-ejemplos-de-diagramas-de-actividades)
- [5. DIAGRAMAS DE ESTADOS](#5-diagramas-de-estados)
  - [5.1. Propósito](#51-propósito)
  - [5.2. Elementos del diagrama](#52-elementos-del-diagrama)
  - [5.3. Estados compuestos](#53-estados-compuestos)
  - [5.4. Ejemplos de diagramas de estados](#54-ejemplos-de-diagramas-de-estados)
- [6. AMPLIACIÓN: DIAGRAMAS COMO CÓDIGO](#6-ampliación-diagramas-como-código)
  - [6.1. PlantUML](#61-plantuml)
  - [6.2. Mermaid](#62-mermaid)
  - [6.3. Ventajas del enfoque "diagrams as code"](#63-ventajas-del-enfoque-diagrams-as-code)
  - [6.4. Modelo C4](#64-modelo-c4-una-alternativa-pragmática-a-uml)
- [7. ¿QUÉ DIAGRAMAS UML SE USAN REALMENTE?](#7-qué-diagramas-uml-se-usan-realmente)
  - [7.1. Frecuencia de uso en la industria](#71-frecuencia-de-uso-en-la-industria)
  - [7.2. El "stack" de diagramas más común](#72-el-stack-de-diagramas-más-común)
  - [7.3. Consejos pragmáticos](#73-consejos-pragmáticos)
  - [7.4. Conclusión: pragmatismo sobre formalismo](#74-conclusión-pragmatismo-sobre-formalismo)

---

## OBJETIVOS

Al finalizar esta unidad, el alumno será capaz de:

- **Interpretar y elaborar diagramas de secuencia**, mostrando la interacción entre objetos a lo largo del tiempo.
- Comprender y aplicar fragmentos combinados en diagramas de secuencia (alt, opt, loop, ref).
- Conocer los diagramas de comunicación y entender por qué se usan raramente en la práctica.
- **Interpretar y elaborar diagramas de actividades**, modelando flujos de trabajo y procesos.
- Aplicar el concepto de swimlanes (calles) para asignar responsabilidades en procesos.
- **Interpretar y elaborar diagramas de estados**, modelando el ciclo de vida de objetos con comportamiento complejo.
- Comprender qué diagramas UML se utilizan realmente en la industria y cuándo usarlos.
- Conocer herramientas modernas de "diagrams as code" (PlantUML, Mermaid) y el modelo C4.

---

## 1. INTRODUCCIÓN

En la unidad anterior (UP08) estudiamos los **fundamentos de UML** y los diagramas estructurales básicos:

- **Casos de uso**: para capturar requisitos funcionales desde la perspectiva del usuario
- **Diagramas de clases**: para diseñar la estructura del código (el diagrama más importante de UML)
- **Diagramas de objetos**: para mostrar instancias concretas en un momento dado

En esta unidad nos centramos en los **diagramas de comportamiento e interacción**, que modelan los aspectos dinámicos del sistema:

| Diagrama | Pregunta que responde | Cuándo usarlo |
| -------- | ---------------------- | --------------- |
| **Secuencia** | ¿Cómo interactúan los objetos para realizar una función? | Para diseñar o documentar la lógica de un escenario concreto |
| **Comunicación** | ¿Qué objetos colaboran y cómo se relacionan? | Raramente (el de secuencia es mejor) |
| **Actividades** | ¿Cuál es el flujo de trabajo o algoritmo? | Para modelar procesos de negocio o flujos complejos |
| **Estados** | ¿Qué estados puede tener un objeto y cómo transiciona? | Para objetos con ciclo de vida complejo |

**Importante**: Ahora que ya conocemos las **clases y objetos** (de UP08), podemos entender cómo estos objetos **interactúan y colaboran** en tiempo de ejecución, lo que es exactamente lo que muestran los diagramas de comportamiento.

---

## 2. DIAGRAMAS DE SECUENCIA

### 2.1. Propósito

El **diagrama de secuencia** muestra cómo los objetos de un sistema interactúan entre sí a lo largo del tiempo para realizar una funcionalidad específica. Responde a la pregunta: *"¿Cómo colaboran los objetos para implementar este caso de uso?"*

**Características principales:**

- Muestra la **secuencia temporal** de mensajes entre objetos.
- Representa **un escenario concreto**, no todas las posibilidades.
- Es muy útil para **diseñar** la lógica interna del sistema.
- Ayuda a identificar **qué métodos** necesita cada clase.

**¿Cuándo se usan?**

- Para detallar cómo se implementa un caso de uso.
- Para diseñar la interacción entre componentes de un sistema.
- Para documentar flujos complejos.
- Para comunicar diseños técnicos entre desarrolladores.

### 2.2. Elementos del diagrama

#### Participantes (Lifelines)

Los **participantes** son los objetos o actores que intervienen en la interacción. Se representan como rectángulos en la parte superior, con una línea vertical discontinua (la *línea de vida*) que desciende.

```text
  ┌─────────┐      ┌─────────┐      ┌─────────┐
  │ :Cliente│      │ :Carrito│      │ :Stock  │
  └────┬────┘      └────┬────┘      └────┬────┘
       │                │                │
       │                │                │
       │                │                │
       ▼                ▼                ▼
```

El nombre puede ser:

- Solo la **clase**: `:Carrito`
- **Objeto** con nombre: `miCarrito:Carrito`
- **Actor**: `Usuario`

#### Mensajes

Los **mensajes** representan la comunicación entre participantes. Se dibujan como flechas horizontales entre **líneas de vida**.

**Tipos de mensajes:**

| Tipo | Representación | Descripción |
| ---- | -------------- | ----------- |
| Síncrono | ——▶ (flecha rellena) | El emisor espera la respuesta |
| Respuesta | ◀- - - (flecha discontinua) | Retorno de un mensaje síncrono |
| Asíncrono | ——> (flecha abierta) | El emisor no espera respuesta |
| Creación | - - - ▶ hacia un rectángulo | Crea un nuevo objeto |
| Destrucción | X al final de la línea de vida | Destruye el objeto |

#### Activación (Focus of control)

Un **rectángulo sobre la línea de vida** indica que el objeto está activo (ejecutando código). Comienza cuando recibe un mensaje y termina cuando devuelve el control.

![Diagrama de secuencia mostrando el concepto de activación con rectángulos sobre líneas de vida y activaciones anidadas](./img/seq-elemento-01-activacion.png)

#### Mensajes a uno mismo (Self-call)

Un objeto puede enviarse mensajes a sí mismo, en cuyo caso se dibuja una flecha que sale y vuelve al mismo rectángulo de activación, creando un nuevo rectángulo de activación anidado.

![Diagrama de secuencia mostrando mensajes a uno mismo (self-call) en un proceso de validación con múltiples auto-llamadas](./img/seq-elemento-02-self-call.png)

#### Creación y destrucción de objetos

Los diagramas de secuencia también pueden mostrar cuándo se **crean** y **destruyen** objetos durante la interacción.

- **Creación**: Se representa con una flecha discontinua hacia el objeto que se está creando (que aparece más abajo en el diagrama).
- **Destrucción**: Se marca con una **X** al final de la línea de vida del objeto.

![Diagrama de secuencia mostrando creación de objetos con create y destrucción con la marca X al final de la línea de vida](./img/seq-elemento-03-creacion-destruccion.png)

#### Tipos de mensajes: comparativa visual

Los diferentes tipos de mensajes tienen notaciones específicas. Este diagrama resume todos los tipos:

![Diagrama de secuencia mostrando comparativa de tipos de mensajes: síncrono, asíncrono, retorno y creación con sus notaciones específicas](./img/seq-elemento-04-tipos-mensajes.png)

### 2.3. Fragmentos combinados

Los **fragmentos combinados** permiten representar flujos de control como condiciones, bucles o alternativas.

#### alt (alternativa)

Representa una elección condicional (if-else):

```text
┌─────────────────────────────────────┐
│ alt  [saldo >= importe]             │
│ ├───────────────────────────────────┤
│ │     realizarPago()                │
│ │◀──────────────────               │
│ ├───────────────────────────────────┤
│ │ [else]                            │
│ │     mostrarError()                │
│ │◀──────────────────               │
└─────────────────────────────────────┘
```

![Diagrama de secuencia mostrando fragmento combinado ALT con dos ramas if-else para retiro de cuenta bancaria](./img/seq-elemento-05-alt.png)

#### opt (opcional)

Representa código que puede ejecutarse o no (if sin else):

```text
┌─────────────────────────────────────┐
│ opt  [usuario.esPremium()]          │
│ ├───────────────────────────────────┤
│ │     aplicarDescuento()            │
│ │◀──────────────────               │
└─────────────────────────────────────┘
```

![Diagrama de secuencia mostrando fragmento combinado OPT con código condicional opcional sin rama else para descuento premium](./img/seq-elemento-06-opt.png)

#### loop (bucle)

Representa repetición:

```text
┌─────────────────────────────────────┐
│ loop  [para cada item en carrito]   │
│ ├───────────────────────────────────┤
│ │     calcularPrecio(item)          │
│ │◀──────────────────                │
└─────────────────────────────────────┘
```

![Diagrama de secuencia mostrando fragmento combinado LOOP para iterar sobre items del carrito calculando precio e impuestos](./img/seq-elemento-07-loop.png)

#### ref (referencia)

Hace referencia a otro diagrama de secuencia. Esto ocurre porque a menudo un proceso de negocio puede ser tan complejo que no es práctico mostrarlo todo en un solo diagrama. En lugar de eso, se puede usar un fragmento `ref` para indicar que en ese punto se realiza una interacción que está detallada en otro diagrama.

```text
┌─────────────────────────────────────┐
│ ref                                 │
│                                     │
│      Proceso de autenticación       │
│                                     │
└─────────────────────────────────────┘
```

![Diagrama de secuencia mostrando fragmento combinado REF para referenciar otros diagramas y evitar repetir detalles](./img/seq-elemento-08-ref.png)

#### Caso completo: combinando fragmentos

Un ejemplo realista que combina varios fragmentos en un solo diagrama. En este caso se muestra un proceso de checkout en una tienda online, donde se verifica el stock de cada producto (loop), se manejan casos de error por falta de stock (alt), y se muestra un mensaje opcional al cliente si hubo algún problema (opt). Además, se podría haber usado un fragmento `ref` para detallar el proceso de pago, pero aquí lo incluimos directamente para mostrar la combinación de fragmentos.

Tienes el diagrama completo (renderizado en PlantUML), así como su snippet de código para que puedas verlo y entender cómo se combinan los fragmentos.

**Código PlantUML:**

```plantuml
@startuml
title Fragmentos Combinados (caso completo)

participant ":Cliente" as C
participant ":CarritoCompra" as Cart
participant ":Producto" as P
participant ":ServicioPago" as SP

C -> Cart: checkout()
activate Cart

loop para cada item
  Cart -> P: verificarStock()
  activate P

  alt stock disponible
    P --> Cart: OK
  else sin stock
    P --> Cart: ERROR
    Cart -> Cart: marcarNoDisponible()
    activate Cart
    deactivate Cart
  end
  deactivate P
end

opt hay items no disponibles
  Cart --> C: "Algunos items no están disponibles"
  note right: Opcional: solo si hubo\nalgún problema de stock
  C -> C: decidir continuar
  activate C
  deactivate C
end

Cart -> SP: procesarPago(total)
activate SP

alt pago exitoso
  SP --> Cart: OK
  Cart --> C: "Pedido confirmado"
else pago rechazado
  SP --> Cart: ERROR
  Cart --> C: "Pago rechazado, intente de nuevo"
end

deactivate SP
deactivate Cart

@enduml
```

![Diagrama de secuencia completo combinando fragmentos LOOP, ALT y OPT en un proceso de checkout realista](./img/seq-elemento-09-combinado.png)

### 2.4. Ejemplos de diagramas de secuencia

#### Ejemplo 1: Autenticación de usuario

El siguiente ejemplo ilustra un proceso de autenticación típico en una aplicación web. El usuario introduce sus credenciales en un formulario de login, que luego interactúa con un servicio de autenticación para verificar las credenciales contra una base de datos. Dependiendo del resultado, se crea una sesión o se muestra un error.

**Código PlantUML:**

```plantuml
@startuml
actor Usuario
participant ":LoginForm" as Form
participant ":AuthService" as Auth
participant ":Database" as DB

Usuario -> Form: introducir credenciales
activate Form
Form -> Auth: login(user, pwd)
activate Auth
Auth -> DB: findUser(user)
activate DB
DB --> Auth: usuario
deactivate DB

alt pwd correcta
  Auth -> Auth: crearSesión()
  Auth --> Form: sesión
else
  Auth --> Form: error
end
deactivate Auth

Form --> Usuario: resultado
deactivate Form
@enduml
```

![Diagrama de secuencia completo de autenticación de usuario mostrando interacción entre Usuario, LoginForm, AuthService y Database con fragmento ALT](./img/seq-01-autenticacion.png)

#### Ejemplo 2: Añadir producto al carrito

Éste es otro de los ejemplos más comunes: el proceso de añadir un producto al carrito en una tienda online. El cliente busca un producto, selecciona uno de los resultados, y luego lo añade al carrito. Durante este proceso, se verifica el stock del producto para asegurar que está disponible.

**Código PlantUML:**

```plantuml
@startuml
actor Cliente
participant ":Catalogo" as Cat
participant ":Producto" as Prod
participant ":Carrito" as Cart

Cliente -> Cat: buscar("café")
activate Cat
Cat --> Cliente: productos
deactivate Cat

Cliente -> Prod: seleccionar producto
activate Prod
Prod --> Cliente: detalles
deactivate Prod

Cliente -> Cart: añadir al carrito
activate Cart
Cart -> Prod: verificar stock
activate Prod
Prod --> Cart: [hay stock]
deactivate Prod
Cart --> Cliente: confirmación
deactivate Cart
@enduml
```

![Diagrama de secuencia mostrando proceso de añadir producto al carrito con verificación de stock en catálogo online](./img/seq-02-carrito.png)

---

## 3. DIAGRAMAS DE COMUNICACIÓN

Los diagramas de comunicación son contenido de ampliación. No se espera que los alumnos los dominen, pero es importante conocer su existencia y entender por qué se usan tan poco en la práctica.

### 3.1. Propósito

El **diagrama de comunicación** (anteriormente llamado *diagrama de colaboración* en UML 1.x) muestra las interacciones entre objetos, pero enfatizando las **relaciones estructurales** entre ellos en lugar del orden temporal.

**Características principales:**

- Muestra la misma información que un diagrama de secuencia, pero con **otro layout**.
- Énfasis en la **estructura** y las relaciones entre objetos, no en el tiempo.
- Los mensajes se numeran para indicar el orden de ejecución.
- Útil cuando la topología de la colaboración es más importante que la secuencia.

**¿Cuándo se usan?**

Teóricamente, cuando:

- Se quiere mostrar la estructura de la colaboración entre objetos
- El foco está en las relaciones, no en la secuencia temporal

**En la práctica:**

- **Casi nunca se usan**. Los diagramas de secuencia hacen el mismo trabajo y son más claros para mostrar el flujo temporal.
- La mayoría de herramientas y desarrolladores prefieren los diagramas de secuencia.

### 3.2. Elementos del diagrama

#### Objetos

Se representan igual que en los diagramas de secuencia: rectángulos con el nombre subrayado.

```text
┌────────────────┐
│ :NombreClase   │
└────────────────┘
```

#### Enlaces (Links)

Líneas que conectan objetos que interactúan. Representan la capacidad de enviar mensajes.

```text
┌──────────┐              ┌──────────┐
│:Cliente  │──────────────│:Carrito  │
└──────────┘              └──────────┘
```

#### Mensajes (Communication)

Flechas sobre los enlaces, numeradas para indicar el orden:

```text
┌──────────┐              ┌──────────┐
│:Cliente  │──1: añadir() │:Carrito  │
└──────────┘              └──────────┘
```

**Numeración de mensajes:**

- `1`: Primer mensaje
- `2`: Segundo mensaje
- `1.1`: Primer mensaje anidado dentro del mensaje 1
- `1.2`: Segundo mensaje anidado dentro del mensaje 1

### 3.3. Ejemplo de diagrama de comunicación

Abajo tienes un ejemplo de diagrama de comunicación. Es posible representar exactamente la misma interacción que en el diagrama de secuencia del ejemplo 2 (añadir producto al carrito), pero con un layout diferente y numerando los mensajes. Al final se suele preferir el diagrama de secuencia porque es más claro para mostrar el flujo temporal.

![Diagrama de comunicación mostrando interacción cliente-carrito-stock con mensajes numerados para indicar el orden de ejecución](./img/com-01-carrito.png)

### 3.4. Uso práctico y alternativas

**En la práctica profesional:**

Los diagramas de comunicación **prácticamente no se usan** porque:

1. **El diagrama de secuencia es superior** para mostrar flujos de interacción.
2. **La numeración manual** de mensajes es tediosa y propensa a errores.
3. **Las herramientas** suelen tener mejor soporte para diagramas de secuencia.
4. **Los desarrolladores están más familiarizados** con diagramas de secuencia.

**Cuándo podrían ser útiles (teóricamente):**

- En sistemas con **topología de red compleja** donde importa más ver quién se comunica con quién que el orden exacto.
- Para **documentar arquitecturas** donde las relaciones son más importantes que las secuencias.

**Pero incluso en esos casos**, suele ser más efectivo usar:

- Un **diagrama de componentes** o de **despliegue** para mostrar la arquitectura
- **Diagramas de secuencia** para los flujos concretos

**Conclusión pragmática:** El diagrama de comunicación está en el estándar UML y en los temarios académicos por razones históricas, pero en la industria **usa diagramas de secuencia** para este propósito. Son más claros, mejor soportados y más conocidos.

---

## 4. DIAGRAMAS DE ACTIVIDADES

### 4.1. Propósito

El **diagrama de actividades** modela el flujo de control o de datos en un proceso. Es similar a un diagrama de flujo tradicional, pero con más expresividad para representar concurrencia y responsabilidades.

**Características principales:**

- Muestra el **flujo de trabajo** paso a paso.
- Puede representar **paralelismo** y **sincronización**.
- Útil tanto para **procesos de negocio** como para **algoritmos**. En cualquier caso, en el tema de procesos de negocio suele ser preferible emplear una notación específica como BPMN, pero el diagrama de actividades es una opción válida y más sencilla para procesos menos formales.
- Permite asignar actividades a diferentes **responsables** mediante calles.

**¿Cuándo se usan?**

- Para modelar procesos de negocio. Aunque **BPMN** es la notación estándar para esto, los diagramas de actividades pueden ser una alternativa más sencilla para procesos menos formales.
- Para documentar flujos de trabajo complejos.
- Para detallar algoritmos antes de implementarlos.
- Para entender y optimizar procesos existentes.

### 4.2. Elementos del diagrama

#### Nodo inicial y final

- **Nodo inicial**: Un círculo negro relleno. Indica dónde comienza el flujo.
- **Nodo final (de actividad)**: Un círculo con un punto negro dentro. Indica dónde termina todo el flujo.
- **Nodo final (de flujo)**: Un círculo con una X. Indica que ese camino termina pero otros pueden continuar.

#### Acción/Actividad

Representa una acción o paso del proceso. Se dibuja como un rectángulo con esquinas redondeadas.

```text
┌─────────────────────┐
│  Procesar pedido    │
└─────────────────────┘
```

#### Flujo (transición)

Una flecha que conecta elementos, indicando el paso de uno a otro.

```text
┌──────────┐         ┌──────────┐
│ Acción A │────────▶│ Acción B │
└──────────┘         └──────────┘
```

#### Decisión y fusión

Un **rombo** representa un punto de decisión (con varias salidas) o de fusión (con varias entradas). Suele ser buena idea anotar las condiciones de decisión o la sincronización de flujos.

#### Bifurcación y unión (fork/join)

Si bien, por las complejidades en que de momento nos movemos, estamos más familiarizados con los flujos secuenciales, esto no es siempre así. En muchos procesos es necesario que varias actividades se realicen en paralelo, o que varias ramas de un proceso se sincronicen antes de continuar. Para esto sirven las barras horizontales.

Una **barra horizontal** representa bifurcación (el flujo se divide en paralelo) o unión (los flujos paralelos se sincronizan). Sincronizarse significa que todas las ramas deben completarse antes de continuar.

**Bifurcación (fork):**

```text
                  │
         ═════════╪═════════
         │        │        │
         ▼        ▼        ▼
      Tarea A  Tarea B  Tarea C
      (paralelo)
```

**Unión (join):**

```text
      Tarea A  Tarea B  Tarea C
         │        │        │
         ═════════╪═════════
                  │
                  ▼
```

### 4.3. Calles (Swimlanes)

Las **calles** (o *swimlanes*) dividen el diagrama en zonas, cada una asignada a un responsable (actor, departamento, sistema). Permiten ver claramente quién hace qué.

```text
│       Cliente      │      Sistema      │      Almacén     │
│                    │                   │                  │
│        ●           │                   │                  │
│        │           │                   │                  │
│        ▼           │                   │                  │
│  ┌───────────┐     │                   │                  │
│  │  Realizar │     │                   │                  │
│  │  pedido   │─────┼──────▶            │                  │
│  └───────────┘     │  ┌───────────┐    │                  │
│                    │  │ Procesar  │    │                  │
│                    │  │ pedido    │────┼────▶             │
│                    │  └───────────┘    │  ┌───────────┐   │
│                    │                   │  │ Preparar  │   │
│                    │                   │  │ envío     │   │
│                    │                   │  └───────────┘   │
```

### 4.4. Ejemplos de diagramas de actividades

Vamos a ver algunos ejemplos de diagramas de actividades para entender cómo se aplican los conceptos vistos. En estos ejemplos combinaremos diferentes elementos como decisiones, bucles, paralelismo y calles para modelar procesos realistas.

Como siempre tenemos el diagrama renderizado y su código PlantUML para que puedas verlo y entender cómo se construye.

#### Ejemplo 1: Proceso de compra online

Este ejemplo modela el proceso de compra en una tienda online, desde que el cliente busca productos hasta que realiza el pago. Incluye un bucle para añadir productos al carrito, una decisión para manejar el resultado del pago, y un manejo de errores en caso de que el pago falle.

**Código PlantUML:**

```plantuml
@startuml
start
:Buscar productos;

while (seguir comprando?) is (sí)
  :Añadir al carrito;
endwhile (no)

:Ir al checkout;
:Identificarse;
:Elegir envío;
:Pagar;

if (pago ok?) then (sí)
  :Confirmar pedido;
  stop
else (no)
  :Mostrar error;
  :Reintentar pago;
  stop
endif
@enduml
```

![Diagrama de actividades mostrando proceso completo de compra online con bucle de añadir productos y decisión de pago con manejo de errores](./img/act-01-compra-online.png)

#### Ejemplo 2: Proceso con paralelismo (preparar pedido en almacén)

Este segundo ejemplo muestra un proceso de preparación de pedido en un almacén, donde se pueden realizar varias tareas en paralelo: preparar los productos y generar la factura. Luego, ambas ramas se sincronizan antes de enviar el pedido.

**Código PlantUML:**

```plantuml
@startuml
start
:Recibir pedido;

fork
  :Preparar productos;
  :Embalar;
fork again
  :Generar factura;
end fork

:Enviar;
stop
@enduml
```

![Diagrama de actividades mostrando proceso con tareas paralelas usando fork y join para preparar pedido y generar factura simultáneamente](./img/act-02-paralelo.png)

#### Ejemplo 3: Proceso con swimlanes (calles)

Por último, este ejemplo muestra un proceso de pedido con responsabilidades asignadas a diferentes actores: el cliente, el sistema y el almacén. Cada actor tiene su propia calle (*swimlane*), lo que facilita ver quién hace qué en cada paso del proceso.

**Código PlantUML:**

```plantuml
@startuml
|Cliente|
start
:Realizar pedido;

|Sistema|
:Procesar pedido;

|Almacén|
:Preparar envío;
:Embalar;
:Enviar;

|Cliente|
:Recibir pedido;
stop
@enduml
```

![Diagrama de actividades con swimlanes mostrando responsabilidades de Cliente, Sistema y Almacén en proceso de pedido](./img/act-03-swimlanes.png)

---

## 5. DIAGRAMAS DE ESTADOS

### 5.1. Propósito

El **diagrama de estados** (o *diagrama de máquina de estados*) modela el comportamiento de un objeto a lo largo de su ciclo de vida, mostrando los estados por los que puede pasar y las transiciones entre ellos.

**Características principales:**

- Se centra en **un solo objeto** o entidad.
- Muestra cómo el objeto **responde a eventos** cambiando de estado.
- Útil para objetos con **comportamiento dependiente del estado**.

**¿Cuándo se usan?**

- Para objetos con ciclo de vida complejo: pedidos, reservas, cuentas de usuario.
- Para protocolos de comunicación: estados de una conexión TCP.
- Para interfaces de usuario: estados de un formulario o pantalla.
- Para sistemas reactivos: dispositivos que responden a eventos.

### 5.2. Elementos del diagrama

#### Estado

Un **estado** representa una situación estable en la vida de un objeto. Se dibuja como un rectángulo con esquinas redondeadas.

Un estado puede tener compartimentos para:

- **Nombre** del estado (obligatorio).
- **Acciones internas**: entry (al entrar), exit (al salir), do (mientras está en el estado).

```text
┌─────────────────────┐
│      En proceso     │
├─────────────────────┤
│ entry/ notificar()  │
│ do/ procesar()      │
│ exit/ limpiar()     │
└─────────────────────┘
```

#### Pseudoestados inicial y final

- **Estado inicial**: Círculo negro relleno. Indica el estado por defecto al crear el objeto.
- **Estado final**: Círculo con punto negro. Indica que el objeto ha terminado su ciclo de vida.

#### Transición

Una **flecha** entre estados representa una transición. Puede incluir:

- **Evento** que dispara la transición.
- **Condición** (guarda) entre corchetes.
- **Acción** que se ejecuta durante la transición.

Formato: `evento [condición] / acción`

```text
┌──────────┐    evento [condición] / acción    ┌──────────┐
│ Estado A │─────────────────────────────────▶│ Estado B │
└──────────┘                                   └──────────┘
```

Ejemplos:

- `click / mostrarMenu` - al hacer click, mostrar menú.
- `timeout [reintentos < 3] / reintentar` - si hay timeout y quedan reintentos.
- `pagar` - simplemente el evento, sin condición ni acción.

### 5.3. Estados compuestos

Un **estado compuesto** contiene subestados dentro. Permite modelar comportamiento jerárquico.

```text
┌─────────────────────────────────────────┐
│              En proceso                 │
│  ┌────────────┐        ┌────────────┐   │
│  │ Validando  │───────▶│ Procesando │   │
│  └────────────┘        └────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

Si ocurre un evento que saca del estado compuesto, se sale independientemente del subestado actual.

### 5.4. Ejemplos de diagramas de estados

Vamos a ver algunos ejemplos de diagramas de estados para entender cómo se aplican los conceptos vistos. En estos ejemplos modelaremos el ciclo de vida de un pedido, los estados de una conexión de red y los estados de un reproductor de música. En cada caso, tendrás el diagrama renderizado y su código PlantUML para que puedas verlo

#### Ejemplo 1: Ciclo de vida de un pedido

Este ejemplo muestra el ciclo de vida completo de un pedido en una tienda online, desde que se crea hasta que se entrega o se cancela. Incluye estados como Pendiente, Confirmado, Pagado, Enviado y Entregado, así como transiciones con eventos como confirmar(), pagar() y enviar().

**Código PlantUML:**

```plantuml
@startuml
[*] --> Pendiente : crearPedido()

Pendiente --> Confirmado : confirmar()
Pendiente --> Cancelado : cancelar()

Confirmado --> Pagado : pagar()
Pagado --> Enviado : enviar()
Enviado --> Entregado : entregar()

Entregado --> [*]
Cancelado --> [*]
@enduml
```

![Diagrama de estados mostrando ciclo de vida completo de un pedido desde creación hasta entrega o cancelación](./img/state-01-pedido.png)

#### Ejemplo 2: Estados de una conexión de red

Este ejemplo modela los estados de una conexión de red, incluyendo estados como Desconectado, Conectando, Conectado y Cerrando. Muestra transiciones para iniciar la conexión, manejar errores y cerrar la conexión.

**Código PlantUML:**

```plantuml
@startuml
[*] --> Desconectado : iniciar

Desconectado --> Conectando : conectar()
Conectando --> Conectado : conexiónEstablecida
Conectando --> Desconectado : timeout

Conectado --> Cerrando : cerrar()
Conectado --> Desconectado : error / reintentar

Cerrando --> Desconectado : cerradoOk

@enduml
```

![Diagrama de estados de una conexión de red mostrando estados Desconectado, Conectando, Conectado y Cerrando con transiciones y manejo de errores](./img/state-02-conexion.png)

#### Ejemplo 3: Estados de un reproductor de música

Este ejemplo muestra los estados de un reproductor de música, incluyendo Parado, Reproduciendo y Pausado. Muestra transiciones para iniciar la reproducción, pausar y detener la música.

**Código PlantUML:**

```plantuml
@startuml
[*] --> Parado

Parado --> Reproduciendo : play [hayCanción]
Reproduciendo --> Pausado : pause
Reproduciendo --> Parado : stop

Pausado --> Reproduciendo : play
Pausado --> Parado : stop

@enduml
```

![Diagrama de estados de un reproductor de música con estados Parado, Reproduciendo y Pausado con transiciones entre ellos](./img/state-03-reproductor.png)

---

## 6. AMPLIACIÓN: DIAGRAMAS COMO CÓDIGO

Una tendencia moderna en el desarrollo de software es tratar los diagramas como código: en lugar de usar herramientas gráficas, se escriben en formato de texto usando una sintaxis específica. Este enfoque se conoce como **"Diagrams as Code"** o **"Documentation as Code"**. Hemos visto ya algunos ejemplos de esto con PlantUML, pero en esta sección profundizaremos en esta práctica y veremos otras herramientas similares.

### 6.1. PlantUML

**PlantUML** es una herramienta que genera diagramas UML a partir de descripciones textuales. Soporta todos los tipos de diagramas UML y muchos otros.

**Instalación y uso:**

- Se puede usar online en [plantuml.com](https://www.plantuml.com/plantuml)
- Se integra con IDEs (VS Code, IntelliJ) mediante plugins
- Se puede usar desde línea de comandos

**Ejemplo: Diagrama de secuencia:**

```plantuml
@startuml
actor Cliente
participant "Carrito" as C
participant "Stock" as S

Cliente -> C: añadirProducto(item)
activate C
C -> S: verificarDisponibilidad(item)
activate S
S --> C: disponible
deactivate S
C --> Cliente: confirmación
deactivate C
@enduml
```

![Diagrama de secuencia básico mostrando interacción Cliente-Carrito-Stock para añadir producto con activación y verificación de disponibilidad](./img/seq-03-basico.png)

**Ejemplo: Diagrama de casos de uso:**

```plantuml
@startuml
left to right direction

actor Cliente
actor Administrador

rectangle "Sistema de Tienda" {
    usecase "Buscar productos" as UC1
    usecase "Realizar pedido" as UC2
    usecase "Gestionar inventario" as UC3
    usecase "Ver informes" as UC4
}

Cliente --> UC1
Cliente --> UC2
Administrador --> UC3
Administrador --> UC4
Administrador --|> Cliente
@enduml
```

![Diagrama de casos de uso mostrando sistema de tienda con actores Cliente y Administrador y sus casos de uso asociados](./img/uc-01-tienda.png)

**Ejemplo: Diagrama de estados:**

```plantuml
@startuml
[*] --> Pendiente

Pendiente --> Confirmado : confirmar()
Pendiente --> Cancelado : cancelar()

Confirmado --> Pagado : pagar()
Pagado --> Enviado : enviar()
Enviado --> Entregado : entregar()

Entregado --> [*]
Cancelado --> [*]
@enduml
```

**Ejemplo: Diagrama de actividades:**

```plantuml
@startuml
start
:Recibir pedido;

fork
  :Preparar productos;
  :Embalar;
fork again
  :Generar factura;
end fork

:Enviar;
stop
@enduml
```

### 6.2. Mermaid

**Mermaid** es similar a PlantUML pero **se integra nativamente** con muchas plataformas de documentación como **GitHub^^, GitLab, Notion, y Markdown en general. La verdadera potencia de Mermaid se manifiesta en ecosistemas de documentación empresarial como Confluence o Notion. Estas plataformas transforman la documentación en un sistema de hipertexto vivo, centralizado y accesible para toda la organización. En este contexto, la integración nativa de Mermaid lo convierte en la elección natural para mantener los diagramas sincronizados y fáciles de consumir.

**Ejemplo: Diagrama de secuencia**:

```mermaid
sequenceDiagram
    actor Cliente
    participant Carrito
    participant Stock

    Cliente->>Carrito: añadirProducto(item)
    activate Carrito
    Carrito->>Stock: verificarDisponibilidad(item)
    activate Stock
    Stock-->>Carrito: disponible
    deactivate Stock
    Carrito-->>Cliente: confirmación
    deactivate Carrito
```

**Ejemplo: Diagrama de estados**:

```mermaid
stateDiagram-v2
    [*] --> Pendiente
    Pendiente --> Confirmado : confirmar()
    Pendiente --> Cancelado : cancelar()
    Confirmado --> Pagado : pagar()
    Pagado --> Enviado : enviar()
    Enviado --> Entregado : entregar()
    Entregado --> [*]
    Cancelado --> [*]
```

**Ejemplo: Diagrama de flujo (similar a actividades)**:

```mermaid
flowchart TD
    A[Inicio] --> B{¿Usuario registrado?}
    B -->|Sí| C[Mostrar dashboard]
    B -->|No| D[Mostrar formulario de registro]
    D --> E[Registrar usuario]
    E --> C
    C --> F[Fin]
```

### 6.3. Ventajas del enfoque "Diagrams as Code"

El enfoque de diagramas como código ofrece múltiples beneficios:

**1. Control de versiones**:

Al ser archivos de texto, los diagramas pueden versionarse con Git igual que el código fuente. Esto permite:

- Ver el historial de cambios del diagrama.
- Hacer diff entre versiones.
- Incluir cambios de diagramas en los mismos commits que los cambios de código.
- Revisiones de código que incluyan los diagramas.

**2. Consistencia con el código**:

Los diagramas viven junto al código, en el mismo repositorio. Esto hace más probable que se mantengan actualizados, ya que:

- Están visibles para los desarrolladores.
- Se pueden actualizar en el mismo pull request que el código.
- Herramientas de CI/CD pueden generar los diagramas automáticamente.

**3. Facilidad de edición**:

No se necesita una herramienta gráfica específica:

- Se pueden editar con cualquier editor de texto.
- Se integran fácilmente en documentación Markdown.
- Son más fáciles de modificar que reorganizar elementos gráficos.

**4. Generación automática**:

Algunas herramientas pueden generar diagramas automáticamente:

- A partir del código fuente (ingeniería inversa).
- A partir de logs o trazas de ejecución.
- Actualizándose cuando cambia el código.

**5. Reproducibilidad**:

El mismo código de diagrama siempre genera el mismo resultado visual. No hay ambigüedad ni dependencia de la configuración de una herramienta gráfica.

### 6.4. Modelo C4: Una alternativa pragmática a UML

Contenido de ampliación: El modelo C4 es un enfoque moderno para la visualización de arquitectura de software que se centra en la simplicidad y la claridad. Fue creado por Simon Brown como una alternativa a UML, que a menudo se percibe como demasiado complejo y difícil de mantener.

> **Nota sobre clasificación:** El modelo C4 **se centra en la arquitectura y estructura del sistema**, por lo que está más alineado con los **diagramas estructurales de UML** (como diagramas de componentes, paquetes y despliegue). Lo incluimos aquí por su relevancia práctica y como alternativa moderna que todo desarrollador debe conocer.

El **modelo C4**, creado por Simon Brown, es un enfoque moderno para la visualización de arquitectura de software que ha ganado gran popularidad en la industria. A diferencia de UML, que ofrece 14 tipos de diagramas con notación específica, C4 propone solo 4 niveles de abstracción con una notación deliberadamente simple.

**Los 4 niveles de C4:**

**Nivel 1: Diagrama de Contexto (Context)**:

Muestra el sistema como una caja negra y sus relaciones con:

- **Usuarios** que interactúan con el sistema.
- **Sistemas externos** con los que se comunica.

Es el "zoom out" máximo: ideal para explicar el sistema a personas no técnicas o nuevos miembros del equipo.

**Código PlantUML:**

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

title Diagrama C4 - Nivel 1: Contexto

Person(cliente, "Cliente", "Usuario que compra productos online")
Person(admin, "Administrador", "Gestiona inventario y pedidos")

System(ecommerce, "Sistema E-commerce", "Permite a los clientes comprar productos online")

System_Ext(email, "Sistema de Email", "SendGrid")
System_Ext(pagos, "Pasarela de Pagos", "Stripe/PayPal")
System_Ext(envios, "Sistema de Envíos", "Correos/UPS")

Rel(cliente, ecommerce, "Compra productos", "HTTPS")
Rel(admin, ecommerce, "Gestiona inventario", "HTTPS")

Rel(ecommerce, email, "Envía confirmaciones", "SMTP")
Rel(ecommerce, pagos, "Procesa pagos", "HTTPS/API")
Rel(ecommerce, envios, "Gestiona envíos", "HTTPS/API")

@enduml
```

![Diagrama C4 nivel 1 Contexto mostrando sistema e-commerce con usuarios Cliente y Administrador y sistemas externos de email, pagos y envíos](./img/c4-01-context.png)

**Nivel 2: Diagrama de Contenedores (Containers):**

"Contenedor" en C4 no significa Docker, sino una **unidad desplegable** que ejecuta código o almacena datos:

- Aplicaciones web, APIs, microservicios
- Bases de datos
- Sistemas de archivos
- Colas de mensajes

Muestra las decisiones tecnológicas de alto nivel. Ideal para arquitectos y desarrolladores técnicos.

**Código PlantUML:**

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

title Diagrama C4 - Nivel 2: Contenedores

Person(cliente, "Cliente", "Usuario de la tienda")
System_Boundary(sistema, "Sistema E-commerce") {
    Container(webapp, "Aplicación Web", "React", "Interfaz de usuario SPA")
    Container(api, "API REST", "Spring Boot", "Lógica de negocio y servicios")
    ContainerDb(db, "Base de datos", "PostgreSQL", "Almacena productos, pedidos, usuarios")
    Container(cache, "Cache", "Redis", "Cache de sesiones y datos frecuentes")
}
System_Ext(pagos, "Sistema de Pagos", "Procesa pagos con tarjeta")
System_Ext(email, "Servidor Email", "Envía confirmaciones")

Rel(cliente, webapp, "Usa", "HTTPS")
Rel(webapp, api, "Llama", "JSON/HTTPS")
Rel(api, db, "Lee/Escribe", "JDBC")
Rel(api, cache, "Lee/Escribe", "Redis Protocol")
Rel(api, pagos, "Procesa pagos", "HTTPS")
Rel(api, email, "Envía emails", "SMTP")

@enduml
```

![Diagrama C4 nivel 2 Contenedores mostrando aplicación web React, API REST Spring Boot, base de datos PostgreSQL, cache Redis y sistemas externos](./img/c4-02-containers.png)

**Nivel 3: Diagrama de Componentes (Components):**

Hace zoom dentro de un contenedor para mostrar sus **componentes internos**: controladores, servicios, repositorios, etc. Ideal para desarrolladores que trabajan en ese contenedor específico.

**Código PlantUML:**

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

title Diagrama C4 - Nivel 3: Componentes (API REST)

Container(webapp, "Aplicación Web", "React", "Interfaz de usuario")
Container_Boundary(api, "API REST") {
    Component(pedidosCtrl, "Pedidos Controller", "Spring MVC", "Endpoints de pedidos")
    Component(productosCtrl, "Productos Controller", "Spring MVC", "Endpoints de productos")
    Component(pedidosService, "Pedidos Service", "Spring Bean", "Lógica de negocio de pedidos")
    Component(productosService, "Productos Service", "Spring Bean", "Lógica de negocio de productos")
    Component(stockService, "Stock Service", "Spring Bean", "Gestión de inventario")
    Component(pedidosRepo, "Pedidos Repository", "Spring Data", "Acceso a datos de pedidos")
    Component(productosRepo, "Productos Repository", "Spring Data", "Acceso a datos de productos")
}
ContainerDb(db, "Base de datos", "PostgreSQL", "Almacena datos")
System_Ext(pagos, "Sistema de Pagos", "Stripe")

Rel(webapp, pedidosCtrl, "Llama", "JSON/HTTPS")
Rel(webapp, productosCtrl, "Llama", "JSON/HTTPS")

Rel(pedidosCtrl, pedidosService, "Usa")
Rel(productosCtrl, productosService, "Usa")

Rel(pedidosService, pedidosRepo, "Usa")
Rel(pedidosService, stockService, "Verifica stock")
Rel(pedidosService, pagos, "Procesa pago", "HTTPS")

Rel(productosService, productosRepo, "Usa")
Rel(productosService, stockService, "Consulta stock")

Rel(pedidosRepo, db, "Lee/Escribe", "JDBC")
Rel(productosRepo, db, "Lee/Escribe", "JDBC")

@enduml
```

![Diagrama C4 nivel 3 Componentes mostrando estructura interna de API REST con controllers, services y repositories organizados en capas](./img/c4-03-components.png)

**Nivel 4: Código (Code):**

El nivel más detallado, equivalente a diagramas de clases UML. Simon Brown recomienda **no crear estos diagramas manualmente**, sino generarlos automáticamente desde el código cuando sea necesario.

**Código PlantUML:**

```plantuml
@startuml
title Diagrama C4 - Nivel 4: Código (Pedidos Service)

note as N1
  Nota: Simon Brown recomienda NO crear estos diagramas manualmente,
  sino generarlos automáticamente desde el código cuando sea necesario.
  Este es un ejemplo simplificado con fines didácticos.
end note

class PedidosService {
  - pedidosRepository: PedidosRepository
  - stockService: StockService
  - pagoService: PagoService
  + crearPedido(datos): Pedido
  + confirmarPedido(id): boolean
  + cancelarPedido(id): void
}

class PedidosRepository {
  + save(pedido): Pedido
  + findById(id): Pedido
  + findByCliente(clienteId): List<Pedido>
}

class StockService {
  + verificarDisponibilidad(productoId, cantidad): boolean
  + reservar(productoId, cantidad): void
  + liberar(productoId, cantidad): void
}

class PagoService {
  + procesarPago(pedido, tarjeta): ResultadoPago
  + reembolsar(pedidoId): boolean
}

class Pedido {
  - id: Long
  - clienteId: Long
  - items: List<ItemPedido>
  - estado: EstadoPedido
  - total: BigDecimal
  + calcularTotal(): BigDecimal
  + validar(): boolean
}

enum EstadoPedido {
  PENDIENTE
  CONFIRMADO
  PAGADO
  ENVIADO
  ENTREGADO
  CANCELADO
}

PedidosService --> PedidosRepository
PedidosService --> StockService
PedidosService --> PagoService
PedidosService ..> Pedido : creates
Pedido --> EstadoPedido

@enduml
```

![Diagrama C4 nivel 4 Código mostrando clases del servicio de pedidos con diagrama de clases UML equivalente](./img/c4-04-code.png)

**¿Cuándo usar C4 vs UML?**

| Aspecto | C4 | UML |
| ------- | --- | --- |
| **Audiencia** | Equipos de desarrollo, stakeholders | Equipos de desarrollo, documentación formal |
| **Curva de aprendizaje** | Baja (4 diagramas, notación simple) | Alta (14 tipos, notación específica) |
| **Formalidad** | Informal, pragmático | Estándar formal (OMG) |
| **Enfoque** | Arquitectura de software | Modelado completo del sistema |
| **Adopción industria** | Creciente, especialmente en DevOps/Agile | Establecido, especialmente en grandes empresas |

**AWS Architecture Diagrams: Otra alternativa práctica:**

En el contexto de cloud computing, especialmente con **AWS (Amazon Web Services)**, ha surgido otro estándar de facto para documentar arquitecturas: los **AWS Architecture Diagrams**. Estos diagramas utilizan iconos oficiales de AWS para representar servicios (EC2, S3, Lambda, RDS, etc.) y sus conexiones.

![Diagrama AWS Architecture](./img/aws-architecture-diagram.png)

**Características:**

- **Iconografía estandarizada**: Cada servicio de AWS tiene su icono oficial reconocible
- **Orientados a infraestructura cloud**: Perfectos para arquitecturas serverless, microservicios en contenedores, etc.
- **Herramientas**: draw.io (diagrams.net), Lucidchart, CloudCraft, AWS Architecture Icons
- **Audiencia**: DevOps, arquitectos cloud, equipos de infraestructura

**Cuándo usarlos:**

- Documentar arquitecturas desplegadas en AWS (o Azure, GCP con sus equivalentes)
- Diseñar infraestructura cloud antes del despliegue
- Comunicar con equipos de operaciones e infraestructura
- Análisis de costes y optimización de recursos cloud

**Relación con C4 y UML:**

- Los AWS Architecture Diagrams son **complementarios** a C4 y UML
- C4 Nivel 1-2 puede mapear a AWS Architecture Diagrams para mostrar la infraestructura
- UML sigue siendo relevante para el diseño del código interno de los servicios
- En la práctica moderna: AWS Diagrams (infraestructura) + C4 (arquitectura lógica) + UML secuencia/clases (diseño detallado)

**Conclusión sobre C4:**

En la práctica profesional, es común ver equipos que combinan diferentes notaciones según el contexto:

- **C4** para documentar arquitectura a alto nivel
- **UML** (especialmente secuencia y clases) para detalles de diseño e interacciones
- **AWS/Azure/GCP Diagrams** para arquitecturas cloud específicas
- **BPMN** para procesos de negocio complejos

No son excluyentes sino complementarios. La clave es elegir la herramienta adecuada para cada audiencia y propósito.

---

**Nota sobre herramientas empresariales**: En entornos corporativos es común encontrar herramientas como **Enterprise Architect**, **IBM Rational**, **MagicDraw** o **Visual Paradigm** en sus versiones comerciales. Estas herramientas ofrecen funcionalidades avanzadas como:

- Gestión de requisitos integrada.
- Generación de código a partir de modelos.
- Ingeniería inversa completa.
- Colaboración en equipo y gestión de versiones de modelos.
- Trazabilidad entre requisitos, modelos y código.
- Informes y documentación automática.

La elección de herramienta depende del contexto del proyecto: para proyectos pequeños o documentación técnica, PlantUML o Mermaid son excelentes opciones; para proyectos empresariales grandes con requisitos de trazabilidad y auditoría, las herramientas comerciales pueden justificar su coste.

---

## 7. ¿QUÉ DIAGRAMAS UML SE USAN REALMENTE?

Una pregunta honesta que todo estudiante debería conocer: **no todos los diagramas UML se usan por igual en la práctica profesional**. Algunos son omnipresentes, otros se usan ocasionalmente, y algunos casi nunca se ven fuera de entornos muy formales.

### 7.1. Frecuencia de uso en la industria

<!-- markdownlint-disable MD029 -->

**Diagramas que se usan CONSTANTEMENTE:**

1. **Diagramas de clases**
   - El rey indiscutible de UML
   - Se usa en diseño detallado, documentación, generación automática de código
   - Prácticamente todos los desarrolladores orientados a objetos lo conocen
   - A menudo se genera automáticamente desde el código (ingeniería inversa)

2. **Diagramas de secuencia**
   - Muy popular para documentar APIs, microservicios, flujos de autenticación
   - Excelente para entender sistemas existentes
   - Se usa mucho en revisiones de diseño y documentación técnica
   - Común en arquitectura de software

**Diagramas que se usan REGULARMENTE:**

3. **Diagramas de actividades**
   - Popular en análisis de procesos de negocio
   - Se usa menos para algoritmos (los desarrolladores prefieren pseudocódigo o tests)
   - Útil cuando hay paralelismo o flujos complejos

4. **Diagramas de estados**
   - Se usa cuando hay objetos con ciclo de vida complejo
   - Común en sistemas embebidos, protocolos, máquinas de estado
   - Menos frecuente en aplicaciones web típicas (CRUD)

**Diagramas que se usan OCASIONALMENTE:**

5. **Diagramas de casos de uso**
   - Se ve en fase inicial de proyectos, sobre todo en entornos formales
   - En equipos ágiles se prefieren user stories o casos de uso narrativos
   - Útil para comunicación con stakeholders no técnicos
   - Poco detalle técnico, más conceptual

6. **Diagramas de componentes**
   - Para arquitectura de alto nivel, módulos del sistema
   - Compite con C4 (que está ganando tracción)

7. **Diagramas de despliegue**
   - Para mostrar infraestructura física/virtual
   - Hoy en día compite con diagramas de arquitectura cloud específicos (AWS, Azure)

**Diagramas que CASI NUNCA se usan:**

8. **Diagramas de comunicación**
   - Prácticamente obsoleto, el de secuencia hace lo mismo mejor

9. **Diagramas de interacción general**
   - Demasiado complejo, poca adopción

10. **Diagramas de temporización**
    - Solo en sistemas de tiempo real muy específicos

11. **Otros diagramas estructurales** menos comunes
    - Diagramas de objetos, diagramas de paquetes, diagramas compuestos, diagrama de perfiles.

<!-- markdownlint-restore -->

### 7.2. El "stack" de diagramas más común

En un proyecto típico de desarrollo de software, el conjunto de diagramas que realmente se crean suele ser:

**Stack mínimo (startup, equipo pequeño):**

- Diagramas de clases (para el modelo de dominio)
- Diagramas de secuencia (para flujos críticos: login, pago, etc.)
- C4 o diagrama de componentes (arquitectura general)

**Stack completo (empresa mediana/grande):**

- Casos de uso (fase de requisitos, opcional)
- Diagramas de clases (diseño del modelo)
- Diagramas de secuencia (interacciones importantes)
- Diagramas de componentes o C4 (arquitectura)
- Diagramas de actividades (procesos de negocio complejos)
- Diagramas de estados (si hay objetos con ciclo de vida complejo)
- Diagramas de despliegue (infraestructura)

**Entorno formal (banca, defensa, aeroespacial):**

- Todos los anteriores
- Trazabilidad requisitos → diseño → código
- Generación automática de documentación
- Herramientas CASE de pago (Enterprise Architect, etc.)

### 7.3. Consejos pragmáticos

**1. No te sientas obligado a usar todos los diagramas:**

UML ofrece 14 tipos de diagramas, pero usar todos sería contraproducente. El objetivo es **comunicar**, no cumplir un checklist.

**2. La documentación que no se mantiene es peor que no tener documentación:**

Un diagrama desactualizado puede confundir más que ayudar. Es mejor:

- Tener pocos diagramas actualizados que muchos obsoletos
- Usar "diagrams as code" versionados con el código
- Generar diagramas automáticamente cuando sea posible

**3. Adapta según tu audiencia:** Diferentes stakeholders necesitan diferentes vistas del sistema:

- **Stakeholders de negocio**: Casos de uso, C4 nivel 1-2, actividades de proceso
- **Arquitectos**: C4, componentes, secuencia de alto nivel
- **Desarrolladores**: Clases, secuencia detallada, estados
- **DevOps**: Despliegue, componentes

**4. El contexto importa:** Según el estado del proyecto, el tipo de sistema y el equipo, algunos diagramas serán más útiles que otros:

- **Proyecto nuevo**: más diagramas de diseño antes de codificar
- **Proyecto existente**: diagramas de ingeniería inversa para entender
- **Documentación de API**: secuencia es rey
- **Sistema legacy complejo**: diagramas de estados para entender el comportamiento

**5. Combina UML con otras herramientas:**

En la práctica, es común usar:

- UML (clases, secuencia) para diseño detallado
- C4 para arquitectura
- Diagramas de arquitectura específicos de cloud (AWS architecture diagrams)
- User stories en lugar de casos de uso formales
- Swagger/OpenAPI para documentar APIs
- ERD (Entity-Relationship Diagrams) para bases de datos

### 7.4. Conclusión: pragmatismo sobre formalismo

UML es una **caja de herramientas**, no una religión. Usa los diagramas que aporten valor al proyecto:

- Si el equipo entiende mejor el sistema con un diagrama de secuencia, créalo.
- Si nadie va a leer un diagrama de casos de uso, no lo hagas.
- Si generar automáticamente diagramas de clases desde el código es más mantenible, hazlo.
- Si C4 comunica mejor que UML componentes, úsalo.

El **mejor diagrama es el que se entiende, se mantiene y aporta valor**. El resto es burocracia.

---

## RESUMEN

En esta unidad hemos profundizado en los **diagramas de comportamiento e interacción** de UML:

1. **Diagramas de secuencia** (el más importante de comportamiento):
   - Muestran cómo los objetos interactúan a lo largo del tiempo
   - Fundamentales para diseñar y documentar flujos complejos
   - Fragmentos combinados (alt, opt, loop, ref) para control de flujo
   - Muy usados en la industria para APIs, microservicios, protocolos

2. **Diagramas de comunicación**:
   - Muestran las mismas interacciones que secuencia, con otro layout
   - **Raramente usados en la práctica** - el de secuencia es superior
   - Solo mencionados por completitud del estándar UML

3. **Diagramas de actividades**:
   - Modelan flujos de trabajo y procesos de negocio
   - Útiles para paralelismo (fork/join) y decisiones complejas
   - Swimlanes para asignar responsabilidades
   - Alternat alternativa a BPMN para procesos de negocio

4. **Diagramas de estados**:
   - Modelan el ciclo de vida de objetos con comportamiento complejo
   - Estados, transiciones, eventos, guardas
   - Útiles en sistemas reactivos, protocolos, máquinas de estado

5. **Diagrams as Code** (PlantUML, Mermaid):
   - Enfoque moderno: escribir diagramas como texto
   - Ventajas: versionado con Git, CI/CD, generación automática
   - Modelo C4 como alternativa pragmática a UML para arquitectura

6. **Pragmatismo sobre formalismo**:
   - No todos los diagramas UML se usan por igual
   - Los más usados: clases, secuencia, actividades, estados
   - Los raramente usados: comunicación, objetos, timing
   - Usar solo los diagramas que aporten valor real

**Conclusión:** Junto con UP08, ahora conoces los diagramas UML esenciales para el desarrollo de software profesional. El "stack" mínimo efectivo es: **casos de uso + clases + secuencia**, y opcionalmente actividades y estados según la naturaleza del proyecto. También a nivel de arquitectura, **C4** o los **AWS Architecture Diagrams** están ganando terreno como alternativas más simples y efectivas que los diagramas de componentes y despliegue de UML.
