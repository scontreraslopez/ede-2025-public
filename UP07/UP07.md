# UP07: Dise√±o Orientado a Objetos

## √çndice

- [1. Introducci√≥n](#1-introducci√≥n)
- [2. Clases y Objetos](#2-clases-y-objetos)
  - [2.1. Clases (El Plano)](#21-clases-el-plano)
  - [2.2. Objetos (La Realidad)](#22-objetos-la-realidad)
  - [2.3. Ampliaci√≥n Kotlin (Para futuros androides)](#23-ampliaci√≥n-kotlin-para-futuros-androides)
- [3. Encapsulamiento y Visibilidad](#3-encapsulamiento-y-visibilidad)
  - [3.1. Modificadores de Visibilidad](#31-modificadores-de-visibilidad)
  - [3.2. Getters y Setters: La Puerta de Entrada Controlada](#32-getters-y-setters-la-puerta-de-entrada-controlada)
  - [3.3. Ampliaci√≥n Kotlin (La magia de las propiedades)](#33-ampliaci√≥n-kotlin-la-magia-de-las-propiedades)
- [4. Herencia](#4-herencia)
  - [4.1. Superclases y Subclases](#41-superclases-y-subclases)
  - [4.2. Implementaci√≥n en Java (`extends` y `super`)](#42-implementaci√≥n-en-java-extends-y-super)
  - [4.3. Sobrescritura de M√©todos (`@Override`)](#43-sobrescritura-de-m√©todos-override)
  - [4.4. Ampliaci√≥n Kotlin (Herencia con `open` y `:`)](#44-ampliaci√≥n-kotlin-herencia-con-open-y-)
- [5. Clases Abstractas](#5-clases-abstractas)
  - [5.1. M√©todos Abstractos](#51-m√©todos-abstractos)
  - [5.2. Implementaci√≥n en Java (`abstract`)](#52-implementaci√≥n-en-java-abstract)
  - [5.3. Ampliaci√≥n Kotlin (Misma palabra clave `abstract`)](#53-ampliaci√≥n-kotlin-misma-palabra-clave-abstract)
- [6. Polimorfismo e Interfaces](#6-polimorfismo-e-interfaces)
  - [6.1. La Soluci√≥n: Interfaces](#61-la-soluci√≥n-interfaces)
  - [6.2. Polimorfismo en Acci√≥n](#62-polimorfismo-en-acci√≥n)
  - [6.3. Ampliaci√≥n Kotlin (Interfaces y Polimorfismo)](#63-ampliaci√≥n-kotlin-interfaces-y-polimorfismo)
- [Recursos Complementarios](#recursos-complementarios)
- [Actividad Propuesta: Los empleados de Temeria. Orden y Orens](#actividad-propuesta-los-empleados-de-temeria-orden-y-orens)
- [Ampliaci√≥n Orden y Orens. Interfaces](#ampliaci√≥n-orden-y-orens-interfaces)
- [Ampliaci√≥n Principios SOLID](#ampliaci√≥n-principios-solid)

## 1. Introducci√≥n

*H√°gase la luz, y fue la luz.* Al principio de los tiempos, los programas eran simples secuencias de instrucciones. Este paradigma, conocido como **Programaci√≥n Estructurada**, permiti√≥ a los desarrolladores crear software funcional y eficiente. En este paradigma, el enfoque principal estaba en las **funciones** y **procedimientos** que manipulaban datos. Datos entraban, se procesaban y sal√≠an, todo en un flujo lineal de *instrucciones / sentencias*.

Por ejemplo, un programa para calcular el IVA de una lista de productos en un fichero de texto contendr√≠a funciones para leer el fichero, calcular el IVA y escribir los resultados en otro fichero:

```java
public class ProgramaIVA {
    // Funci√≥n para calcular el IVA
    public static double calcularIVA(double[] precios) {
        double totalIVA = 0;
        for (double precio : precios) {
            totalIVA += precio * 0.21;
        }
        return totalIVA;
    }

    // Funci√≥n para leer un fichero (simulada)
    public static double[] leerFichero(String nombreFichero) {
        // Aqu√≠ ir√≠a la l√≥gica de lectura
        return new double[]{100, 200, 50}; // ejemplo
    }

    // Funci√≥n para escribir un fichero (simulada)
    public static void escribirFichero(String nombreFichero, double resultado) {
        System.out.println("IVA total: " + resultado);
    }

    // Punto de entrada: flujo principal
    public static void main(String[] args) {
        double[] productos = leerFichero("productos.txt");
        double ivaTotal = calcularIVA(productos);
        escribirFichero("resultados.txt", ivaTotal);
    }
}
```

Pero a medida que los sistemas crec√≠an en complejidad, surgi√≥ la necesidad de una nueva forma de pensar sobre el dise√±o del software. Esto era especialmente evidente a la hora de querer **modificar o ampliar funcionalidades** sin afectar otras partes del sistema, te obligaba a estar familiarizado con todo el c√≥digo y su l√≥gica interna, lo cual es muy dif√≠cil en *codebases* grandes adem√°s de ser propenso a **errores**. Imag√≠nate que ahora te piden que algunos productos tienen un IVA reducido o est√°n exentos, tendr√≠as que modificar la funci√≥n de c√°lculo del IVA y posiblemente otras partes del c√≥digo, lo que aumenta el riesgo de introducir errores.

As√≠ naci√≥ el paradigma de la **Programaci√≥n Orientada a Objetos (POO)**, una revoluci√≥n que transform√≥ la manera en que concebimos y construimos aplicaciones. La POO introduce conceptos fundamentales como **clases**, **objetos**, **encapsulamiento**, **herencia** y **polimorfismo**, que permiten a los desarrolladores modelar el mundo real de una manera m√°s intuitiva y manejable. Al encapsular datos y comportamientos dentro de objetos, la POO facilita la **reutilizaci√≥n del c√≥digo**, mejora la **mantenibilidad** y permite una mayor **modularidad** en el dise√±o del software. En este cap√≠tulo, exploraremos los principios b√°sicos de la POO y c√≥mo aplicarlos para crear sistemas m√°s robustos y flexibles. Por ejemplo, el mismo programa de c√°lculo de IVA podr√≠a ser reestructurado utilizando POO de la siguiente manera:

```java
// Clase que representa un producto
class Producto {
    // ESTADO (Datos)
    private double precio;

    public Producto(double precio) {
        this.precio = precio;
    }

    // COMPORTAMIENTO (M√©todos)
    // El producto es responsable de saber su propio impuesto
    public double calcularIVA() {
        return this.precio * 0.21;
    }
}

// Clase que maneja la l√≥gica del programa
public class ProgramaIVA {
    // M√©todo para leer productos desde un fichero (simulado)
    public static Producto[] leerFichero(String nombreFichero) {
        // Aqu√≠ ir√≠a la l√≥gica de lectura
        return new Producto[]{new Producto(100), new Producto(200), new Producto(50)}; // ejemplo
    }

    // M√©todo para escribir resultados en un fichero (simulado)
    public static void escribirFichero(String nombreFichero, double resultado) {
        System.out.println("IVA total: " + resultado);
    }

    // Punto de entrada: flujo principal
    public static void main(String[] args) {
        Producto[] productos = leerFichero("productos.txt");
        double ivaTotal = 0;
        for (Producto producto : productos) {
            ivaTotal += producto.calcularIVA();
        }
        escribirFichero("resultados.txt", ivaTotal);
    }
}
```

En este enfoque orientado a objetos, cada producto es una instancia de la clase `Producto`, que encapsula tanto el precio como el m√©todo para calcular el IVA. Esto no solo mejora la **claridad del c√≥digo**, sino que tambi√©n facilita la **extensi√≥n y modificaci√≥n** del programa en el futuro. Gracias a otras caracter√≠sticas de la POO, como la **herencia** y el **polimorfismo**, podemos crear jerarqu√≠as de clases y comportamientos din√°micos que se adaptan a las necesidades cambiantes del software moderno, por ejemplo para productos con diferentes tipos de IVA (exento, reducido, general, etc.), lo cual ser√≠a mucho m√°s complicado de manejar en un enfoque estructurado.

> [!NOTE]
> En este enfoque, cada producto es una **instancia** de la **clase** `Producto`, que encapsula tanto el **estado** (precio) como el **comportamiento** (m√©todo para calcular el IVA). Estos viajan junto en una *c√°psula* llamada objeto. Esto facilita que si ma√±ana cambia la ley del IVA, s√≥lo tengamos que modificar la clase `Producto` sin prestar atenci√≥n al resto del c√≥digo.

![Diagrama conceptual objeto POO](capsula_producto.png)

Es esta **facilidad para modelar sistemas complejos** por analog√≠a con la realidad y **adaptarse a cambios** lo que ha hecho de la Programaci√≥n Orientada a Objetos un pilar fundamental en el desarrollo de software contempor√°neo.

> [!TIP]
> En ingl√©s se utiliza el acr√≥nimo **OOP** (*Object-Oriented Programming*) para referirse a la Programaci√≥n Orientada a Objetos.

## 2. Clases y Objetos

En la Programaci√≥n Orientada a Objetos, los **objetos** son las unidades fundamentales que representan entidades del mundo real o conceptos abstractos dentro de un programa. Un objeto es una instancia de una **clase**, que act√∫a como un molde o plantilla que define las caracter√≠sticas y comportamientos comunes de esos objetos.

### 2.1. Clases (El Plano)

Una **clase** es una definici√≥n que agrupa datos y m√©todos relacionados. No es el objeto en s√≠, sino las instrucciones para crearlo.

- **Atributos (Datos):** Representan el estado (color, marca, velocidad).
- **M√©todos (Comportamiento):** Representan lo que el objeto sabe hacer (arrancar, frenar).

Por ejemplo, la clase `Coche`:

```java
class Coche {
    // Atributos (estado)
    private String marca;
    private String modelo;
    private int a√±o;

    // CONSTRUCTOR: El m√©todo especial que se ejecuta al "nacer" el objeto
    public Coche(String marca, String modelo, int a√±o) {
        this.marca = marca;
        this.modelo = modelo;
        this.a√±o = a√±o;
    }

    // M√©todos (comportamiento)
    public void arrancar() {
        System.out.println("El coche " + marca + " " + modelo + " est√° arrancando.");
    }

    public void detener() {
        System.out.println("El coche " + marca + " " + modelo + " se ha detenido.");
    }
}
```

**Nota importante:** Una clase no ocupa memoria de ejecuci√≥n por s√≠ misma; es simplemente papel mojado hasta que usamos la palabra m√°gica: `new`.

### 2.2. Objetos (La Realidad)

Un **objeto** es una instancia concreta creada a partir de la clase. Aqu√≠ es donde ocurre la magia:

1. La palabra clave **`new`** reserva espacio real en la memoria del ordenador.
2. Se llama al **constructor** para rellenar los datos iniciales.

De una sola clase `Coche`, podemos fabricar infinitos objetos distintos:

```java
public class Main {
    public static void main(String[] args) {
        // 1. Instanciaci√≥n: 'new' crea el objeto en memoria
        // 'miCoche' es la variable que nos permite controlarlo
        Coche miCoche = new Coche("Opel", "Corsa", 2008);
        Coche tuCoche = new Coche("Honda", "Civic", 2019);

        // 2. Interacci√≥n: Usamos el punto (.) para pedirle al objeto que haga cosas
        miCoche.arrancar(); // El Opel arranca
        tuCoche.arrancar(); // El Honda arranca

        miCoche.detener();
    }
}
```

### 2.3. Ampliaci√≥n Kotlin (Para futuros androides)

Kotlin es un lenguaje moderno que simplifica enormemente la escritura de c√≥digo (boilerplate). Es el lenguaje oficial de Android y, aunque es tan potente como Java, tiene una sintaxis limpia y concisa que recuerda a Python.

F√≠jate c√≥mo todo el c√≥digo anterior se reduce dr√°sticamente porque el constructor y la declaraci√≥n de propiedades se fusionan en la misma l√≠nea:

```kotlin
// En una sola l√≠nea definimos clase, atributos y constructor
class Coche(private val marca: String, private val modelo: String, private val a√±o: Int) {
    
    fun arrancar() {
        // Usamos $ para insertar variables directamente en el texto (String Templates)
        println("El coche $marca $modelo est√° arrancando.")
    }

    fun detener() {
        println("El coche $marca $modelo se ha detenido.")
    }
}

fun main() {
    // No necesitamos 'new', Kotlin es listo
    val miCoche = Coche("Opel", "Corsa", 2008)
    val tuCoche = Coche("Honda", "Civic", 2019)

    miCoche.arrancar()
    tuCoche.arrancar()
}
```

Si te interesa Kotlin, no olvides consultar su web oficial: [kotlinlang.org](https://kotlinlang.org/). Es la evoluci√≥n natural que ver√©is en el m√≥dulo de PMDM (Programaci√≥n Multimedia y Dispositivos M√≥viles).

## 3. Encapsulamiento y Visibilidad

El **encapsulamiento** es uno de los pilares de la POO y se puede resumir en una idea muy simple: **proteger los datos de un objeto**. La idea es tratar a los objetos como "cajas negras": conocemos su interfaz p√∫blica (los botones que podemos pulsar), pero no necesitamos saber (ni nos debe importar) c√≥mo funcionan por dentro.

> [!NOTE]
> El objetivo del encapsulamiento es **proteger la integridad del estado interno de un objeto** y **controlar c√≥mo se accede y modifica ese estado**. Al desarrollador le reduce la carga cognitiva, ya que no necesita entender los detalles internos de cada objeto para usarlo correctamente, solo su interfaz p√∫blica (qu√© m√©todos puede llamar y lo que √©stos devuelven). No confundir con la encriptaci√≥n ni la seguridad inform√°tica, no es ese tipo de protecci√≥n.

Imagina un coche. T√∫ no inyectas gasolina directamente en el pist√≥n con una jeringuilla. En su lugar, pisas el pedal del acelerador (un m√©todo p√∫blico), y el coche se encarga internamente de gestionar el motor, la inyecci√≥n y la combusti√≥n (l√≥gica privada). Esto protege la integridad del motor y simplifica su uso.

En programaci√≥n, esto se logra ocultando el estado interno de un objeto (sus atributos) y exponiendo solo los m√©todos necesarios para interactuar con √©l. Para controlar qui√©n puede ver o modificar qu√©, usamos los **modificadores de visibilidad**.

### 3.1. Modificadores de Visibilidad

Estos son los "permisos" que le damos a nuestro c√≥digo. Los m√°s comunes son:

| Modificador | Visibilidad                                                              |
| :---------- | :------------------------------------------------------------------------ |
| `public`    | Accesible desde cualquier parte del programa.                             |
| `private`   | Accesible **solo** desde dentro de la propia clase.                       |
| `protected` | Accesible desde la propia clase y desde las clases que hereden de ella. |
| *default*   | (Si no se especifica) Accesible solo desde clases del mismo paquete.      |

> [!IMPORTANT]
> Por norma general, **todos los atributos de una clase deben ser `private`**. El acceso a ellos se debe gestionar a trav√©s de m√©todos p√∫blicos.

Un paquete es como una carpeta que agrupa clases relacionadas. Por ejemplo `ui` en la imagen de abajo que contendr√≠a todas las clases relacionadas con la interfaz de usuario.

![Package](package.png)

### 3.2. Getters y Setters: La Puerta de Entrada Controlada

Si los atributos deben ser privados, ¬øc√≥mo los leemos o modificamos? --> A trav√©s de m√©todos p√∫blicos dise√±ados espec√≠ficamente para ello:

- **Getters:** M√©todos para *obtener* el valor de un atributo (solo lectura). Suelen empezar por `get...`.
- **Setters:** M√©todos para *establecer* el valor de un atributo (escritura). Permiten a√±adir l√≥gica de validaci√≥n. Suelen empezar por `set...`.

Veamos un ejemplo con una cuenta bancaria. Queremos asegurarnos de que el saldo nunca sea negativo y que solo se puedan ingresar cantidades positivas.

```java
public class CuentaBancaria {
    private double saldo; // Atributo privado. Nadie puede modificarlo directamente.

    // CONSTRUCTOR
    public CuentaBancaria() {
        this.saldo = 0.0; // Saldo inicial
    }

    // GETTER: Permite consultar el saldo desde fuera
    public double getSaldo() {
        return this.saldo;
    }

    // M√âTODO P√öBLICO que modifica el estado (similar a un setter)
    public void ingresar(double cantidad) {
        if (cantidad > 0) {
            this.saldo += cantidad;
        } else {
            System.out.println("Error: La cantidad a ingresar debe ser positiva.");
        }
    }

    // OTRO M√âTODO P√öBLICO que modifica el estado
    public void retirar(double cantidad) {
        if (cantidad > 0 && this.saldo >= cantidad) {
            this.saldo -= cantidad;
        } else {
            System.out.println("Error: Cantidad inv√°lida o saldo insuficiente.");
        }
    }
}

// Uso desde otra clase
CuentaBancaria miCuenta = new CuentaBancaria();
miCuenta.ingresar(100.0); // Correcto
System.out.println("Saldo actual: " + miCuenta.getSaldo()); // Imprime 100.0

miCuenta.retirar(30.0); // Correcto
System.out.println("Saldo actual: " + miCuenta.getSaldo()); // Imprime 70.0

miCuenta.retirar(80.0); // Incorrecto, saldo insuficiente. El m√©todo lo impide.
System.out.println("Saldo final: " + miCuenta.getSaldo()); // Sigue siendo 70.0
```

> [!TIP]
> ¬°No escribas los getters y setters a mano! Todos los IDEs modernos (IntelliJ, Eclipse, VS Code) pueden generarlos autom√°ticamente. En IntelliJ, haz clic derecho en la clase -> `Generate...` -> `Getter and Setter`.

### 3.3. Ampliaci√≥n Kotlin (La magia de las propiedades)

Aqu√≠ es donde Kotlin brilla por su concisi√≥n. En Kotlin, los getters y setters se generan autom√°ticamente para las propiedades declaradas con `var` (variable) o `val` (constante). Son invisibles, pero existen.

```kotlin
class CuentaBancaria {
    var saldo: Double = 0.0
        private set // El setter es privado, solo se puede modificar desde dentro de la clase

    // M√©todo p√∫blico para ingresar dinero
    fun ingresar(cantidad: Double) {
        if (cantidad > 0) {
            saldo += cantidad
        } else {
            println("Error: La cantidad a ingresar debe ser positiva.")
        }
    }

    // M√©todo p√∫blico para retirar dinero
    fun retirar(cantidad: Double) {
        if (cantidad > 0 && saldo >= cantidad) {
            saldo -= cantidad
        } else {
            println("Error: Cantidad inv√°lida o saldo insuficiente.")
        }
    }
}

// Uso desde otra parte
fun main() {
    val miCuenta = CuentaBancaria()
    miCuenta.ingresar(100.0)
    println("Saldo actual: ${miCuenta.saldo}") // Imprime 100.0

    miCuenta.retirar(30.0)
    println("Saldo actual: ${miCuenta.saldo}") // Imprime 70.0

    miCuenta.retirar(80.0) // Incorrecto, saldo insuficiente
    println("Saldo final: ${miCuenta.saldo}") // Sigue siendo 70.0
}
```

----

## 4. Herencia

La **herencia** es un mecanismo que permite a una clase (llamada **clase hija** o **subclase**) adquirir los atributos y m√©todos de otra clase (llamada **clase padre** o **superclase**). Es la forma que tiene la POO de representar la relaci√≥n **"es un..."**.

- Un `Coche` **es un** `Vehiculo`.
- Un `Perro` **es un** `Animal`.
- Un `Guerrero` **es un** `Personaje`.

El objetivo principal es la **reutilizaci√≥n de c√≥digo**. En lugar de reescribir las mismas propiedades y comportamientos una y otra vez, los defines una vez en la clase padre y las clases hijas los heredan autom√°ticamente.

![Diagrama Herencia](herencia.png)

### 4.1. Superclases y Subclases

- **Superclase (Padre):** La clase general que contiene los atributos y m√©todos comunes. Ejemplo: `Vehiculo`.
- **Subclase (Hija):** La clase especializada que hereda de la superclase y puede a√±adir sus propios atributos y m√©todos, o modificar los heredados. Ejemplo: `Coche`, `Bicicleta`.

### 4.2. Implementaci√≥n en Java (`extends` y `super`)

En Java, usamos la palabra clave `extends` para indicar que una clase hereda de otra.

```java
// CLASE PADRE (Superclase)
public class Vehiculo {
    protected String marca; // 'protected' es visible para la clase y sus hijas
    protected String modelo;

    // Constructor de la clase padre
    public Vehiculo(String marca, String modelo) {
        this.marca = marca;
        this.modelo = modelo;
    }

    public void arrancar() {
        System.out.println("El veh√≠culo " + marca + " " + modelo + " ha arrancado.");
    }
}

// CLASE HIJA (Subclase)
public class Coche extends Vehiculo {
    private int numeroPuertas; // Atributo espec√≠fico de Coche

    // Constructor de la clase hija
    public Coche(String marca, String modelo, int numeroPuertas) {
        // 1. La primera llamada DEBE ser a 'super()' para construir la parte "Vehiculo"
        super(marca, modelo); 
        // 2. Luego, inicializamos los atributos propios de Coche
        this.numeroPuertas = numeroPuertas;
    }
}

// USO
Coche miCoche = new Coche("Seat", "Ibiza", 5);
miCoche.arrancar(); // -> "El veh√≠culo Seat Ibiza ha arrancado." (M√©todo heredado)
```

> [!IMPORTANT]
> La palabra clave `super()` llama al constructor de la clase padre. Es obligatorio llamarlo y debe ser la **primera instrucci√≥n** en el constructor de la clase hija.

### 4.3. Sobrescritura de M√©todos (`@Override`)

Una clase hija puede proporcionar su propia implementaci√≥n de un m√©todo que ya existe en la clase padre. Esto se llama **sobrescritura** (*overriding*). Para ello, se utiliza la anotaci√≥n `@Override`, que le indica al compilador nuestra intenci√≥n y nos avisa si cometemos un error (por ejemplo, si el nombre del m√©todo no coincide).

```java
public class CocheElectrico extends Coche {

    public CocheElectrico(String marca, String modelo, int numeroPuertas) {
        super(marca, modelo, numeroPuertas);
    }

    // Sobrescribimos el m√©todo arrancar() para que sea diferente
    @Override
    public void arrancar() {
        // Podr√≠amos llamar al m√©todo original del padre si queremos con 'super'
        // super.arrancar(); 
        System.out.println("El coche el√©ctrico " + marca + " " + modelo + " arranca en silencio.");
    }
}

// USO
CocheElectrico miTesla = new CocheElectrico("Tesla", "Model 3", 5);
miTesla.arrancar(); // -> "El coche el√©ctrico Tesla Model 3 arranca en silencio."
```

### 4.4. Ampliaci√≥n Kotlin (Herencia con `open` y `:`)

En Kotlin, la herencia es m√°s expl√≠cita para evitar errores. Por defecto, todas las clases son `final` (no se puede heredar de ellas). Para permitir la herencia, debes marcar la clase padre con la palabra clave `open`. Lo mismo ocurre con los m√©todos que quieras sobrescribir.

- **`open class`**: Permite que otras clases hereden de esta.
- **`open fun`**: Permite que las clases hijas sobrescriban este m√©todo.
- **`:`**: Reemplaza a `extends` de Java.
- **`override`**: Reemplaza a la anotaci√≥n `@Override`.

```kotlin
// CLASE PADRE (debe ser 'open')
open class Vehiculo(protected val marca: String, protected val modelo: String) {
    
    // El m√©todo tambi√©n debe ser 'open' para poder ser sobrescrito
    open fun arrancar() {
        println("El veh√≠culo $marca $modelo ha arrancado.")
    }
}

// CLASE HIJA (hereda con ':')
// Tambi√©n la marcamos como 'open' para que CocheElectrico pueda heredar de ella
open class Coche(
    marca: String, 
    modelo: String, 
    private val numeroPuertas: Int
) : Vehiculo(marca, modelo) { // Llama al constructor del padre
    // No necesita cuerpo si no a√±ade m√°s l√≥gica
}

// OTRA CLASE HIJA. No se podr√° heredar de Bicicleta porque no es 'open'
class Bicicleta(
    marca: String, 
    modelo: String
) : Vehiculo(marca, modelo) {
    // Bicicleta no a√±ade nada m√°s por ahora
}

// CLASE NIETA que sobrescribe un m√©todo
class CocheElectrico(
    marca: String, 
    modelo: String, 
    numeroPuertas: Int
) : Coche(marca, modelo, numeroPuertas) {

    // Sobrescribimos el m√©todo arrancar() con la palabra clave 'override'
    override fun arrancar() {
        println("El coche el√©ctrico $marca $modelo arranca en silencio.")
    }
}

// USO
fun main() {
    val miCoche = Coche("Seat", "Ibiza", 5)
    miCoche.arrancar() // -> "El veh√≠culo Seat Ibiza ha arrancado."

    val miTesla = CocheElectrico("Tesla", "Model 3", 5)
    miTesla.arrancar() // -> "El coche el√©ctrico Tesla Model 3 arranca en silencio."
}
```

## 5. Clases Abstractas

A veces, en la jerarqu√≠a de la herencia, existen clases que son tan generales que no tiene sentido crear objetos de ellas. Por ejemplo, ¬øhas visto alguna vez un "Animal" gen√©rico paseando por la calle? No. Ves un perro, un gato o una paloma, que son tipos espec√≠ficos de animales. En POO, "Animal" ser√≠a un concepto, una plantilla, no un objeto real.

Una **clase abstracta** es una clase que sirve como plantilla para otras clases, pero de la cual **no se pueden crear instancias** (objetos). Su prop√≥sito es definir una estructura y un comportamiento comunes que sus clases hijas deben seguir.

> [!IMPORTANT]
> Regla de oro: Si una clase es `abstract`, **no puedes hacer `new ClaseAbstracta()`**. Su √∫nica finalidad es ser heredada por otras clases.

### 5.1. M√©todos Abstractos

La verdadera potencia de las clases abstractas reside en los **m√©todos abstractos**. Un m√©todo abstracto es una declaraci√≥n de un m√©todo sin implementaci√≥n (sin cuerpo, sin `{...}`). Es como un contrato que obliga a todas las clases hijas a proporcionar su propia versi√≥n de ese m√©todo.

- Si una clase contiene uno o m√°s m√©todos abstractos, la clase entera **debe** ser declarada como `abstract`.
- Una clase hija que hereda de una clase abstracta est√° **obligada** a implementar (sobrescribir) todos los m√©todos abstractos de su padre.

### 5.2. Implementaci√≥n en Java (`abstract`)

Usemos el ejemplo de un juego de rol. Todos los personajes (`Personaje`) tienen un nombre y vida, pero cada uno ataca de forma diferente. `Personaje` es un candidato perfecto para ser una clase abstracta.

```java
// CLASE ABSTRACTA: No se puede instanciar new Personaje()
public abstract class Personaje {
    protected String nombre;
    protected int vida;

    public Personaje(String nombre, int vida) {
        this.nombre = nombre;
        this.vida = vida;
    }

    // M√âTODO ABSTRACTO: Sin implementaci√≥n. Obliga a las hijas a definirlo.
    public abstract void atacar();

    // M√âTODO CONCRETO: Comportamiento com√∫n que se hereda directamente.
    public void recibirDa√±o(int da√±o) {
        this.vida -= da√±o;
        System.out.println(nombre + " recibe " + da√±o + " puntos de da√±o. Vida restante: " + vida);
    }
}

// CLASE HIJA CONCRETA: Implementa el m√©todo abstracto
public class Guerrero extends Personaje {
    private int fuerza;

    public Guerrero(String nombre, int vida, int fuerza) {
        super(nombre, vida);
        this.fuerza = fuerza;
    }

    // Implementaci√≥n obligatoria del m√©todo abstracto
    @Override
    public void atacar() {
        System.out.println(nombre + " ataca con su espada, causando " + fuerza + " de da√±o f√≠sico.");
    }
}

// OTRA CLASE HIJA CONCRETA
public class Mago extends Personaje {
    private int poderMagico;

    public Mago(String nombre, int vida, int poderMagico) {
        super(nombre, vida);
        this.poderMagico = poderMagico;
    }

    // Implementaci√≥n obligatoria, pero diferente a la del Guerrero
    @Override
    public void atacar() {
        System.out.println(nombre + " lanza un hechizo, causando " + poderMagico + " de da√±o m√°gico.");
    }
}

// USO
// Personaje p = new Personaje("Gen√©rico", 100); // ¬°ERROR DE COMPILACI√ìN! No se puede instanciar.
Guerrero conan = new Guerrero("Conan", 150, 25);
Mago gandalf = new Mago("Gandalf", 80, 40);

conan.atacar();   // -> "Conan ataca con su espada..."
gandalf.atacar(); // -> "Gandalf lanza un hechizo..."
```

### 5.3. Ampliaci√≥n Kotlin (Misma palabra clave `abstract`)

Kotlin utiliza la misma palabra clave `abstract` tanto para clases como para m√©todos, manteniendo la l√≥gica de Java pero con una sintaxis m√°s limpia.

```kotlin
// CLASE ABSTRACTA
abstract class Personaje(protected val nombre: String, protected var vida: Int) {
    
    // M√âTODO ABSTRACTO
    abstract fun atacar()

    // M√âTODO CONCRETO
    fun recibirDa√±o(da√±o: Int) {
        vida -= da√±o
        println("$nombre recibe $da√±o puntos de da√±o. Vida restante: $vida")
    }
}

// CLASE HIJA CONCRETA
class Guerrero(nombre: String, vida: Int, private val fuerza: Int) : Personaje(nombre, vida) {
    
    override fun atacar() {
        println("$nombre ataca con su espada, causando $fuerza de da√±o f√≠sico.")
    }
}

// OTRA CLASE HIJA CONCRETA
class Mago(nombre: String, vida: Int, private val poderMagico: Int) : Personaje(nombre, vida) {

    override fun atacar() {
        println("$nombre lanza un hechizo, causando $poderMagico de da√±o m√°gico.")
    }
}

fun main() {
    // val p = Personaje("Gen√©rico", 100) // ¬°ERROR! No se puede instanciar
    val conan = Guerrero("Conan", 150, 25)
    val gandalf = Mago("Gandalf", 80, 40)

    conan.atacar()
    gandalf.atacar()
}
```

En resumen, las clases abstractas son la herramienta perfecta para definir una "idea" o "concepto" base que comparte c√≥digo com√∫n pero que necesita que sus especializaciones completen los detalles.

## Recursos Complementarios

- Playlist Curso POO (Youtube): [https://www.youtube.com/watch?v=L8ywM1BQwT0&list=PLU8oAlHdN5Bmfy5fL2-ByDUGa9cMagEXK&index=1](https://www.youtube.com/watch?v=L8ywM1BQwT0&list=PLU8oAlHdN5Bmfy5fL2-ByDUGa9cMagEXK&index=1)

## Actividad Propuesta: Los empleados de Temeria. Orden y Orens

En el universo de Andrzej Sapkowski, Temeria es un reino pr√≥spero conocido por su diversidad cultural y su compleja estructura social. Nos situamos en un momento en el que el rey Foltest sigue gobernando, y la administraci√≥n del reino est√° en pleno auge. Para gestionar eficientemente los recursos humanos del reino, se ha decidido implementar un sistema de gesti√≥n de empleados utilizando los principios de la Programaci√≥n Orientada a Objetos (POO).

A continuaci√≥n encontrar√°s el mensaje del rey Foltest solicitando tu ayuda:

**DE:** Su Majestad el Rey Foltest, Se√±or de Temeria, Pontar y Mahakam.
**PARA:** El Gran Maestro de la L√≥gica (T√∫, el alumno).
**ASUNTO:** Proyecto "Orden y Orens".

Las arcas de Temeria son un desastre. Mi chambel√°n mezcla las n√≥minas de mis leales caballeros con los pagos a esos brujos mutantes que vagan por los caminos. Ayer casi le pagamos vacaciones pagadas a un mercenario borracho, y la hechicera Triss Merigold est√° furiosa porque le hemos pagado por horas como si fuera una jornalera.

Necesito que pongas orden en este caos. Debes dise√±ar el **Sistema de Gesti√≥n de S√∫bditos (SGS)** utilizando tus artes arcanas (Java y POO).

El sistema debe distinguir claramente entre quienes sirven en mi corte y quienes trabajan bajo contrato temporal. Aqu√≠ tienes las especificaciones del escriba real:

----

### 1. El Registro √önico (`Empleado`)

Todo aquel que reciba un Oren de mis arcas debe estar registrado. No importa si es noble o plebeyo, todos comparten:

- Un **Nombre** y una **Edad**.
- Todos deben **`trabajar()`**, aunque cada uno lo haga a su manera.
- Todos deben **`calcularSalario()`**, pues nadie trabaja gratis.
- *Nota del Escriba:* Como no existe un "trabajador gen√©rico" (nadie cobra por respirar), este registro debe ser **Abstracto**.

### 2. Las Dos Castas

Mi corte se divide en dos grandes grupos. Debes crear una distinci√≥n clara (Clases Intermedias):

#### A. La Nobleza de Palacio (`EmpleadoCorte`)

Son mis leales servidores fijos. Viven en el castillo y comen de mi mesa.

- Gozan de un **Sueldo Fijo** mensual, pase lo que pase.
- Tienen el privilegio de **`solicitarVacaciones()`**. Cuando lo hacen, deben presentar una solicitud formal ante el chambel√°n.

#### B. Los Caminantes (`EmpleadoExterno`)

Son profesionales libres. Hoy est√°n aqu√≠, ma√±ana en Redania.

- No tienen sueldo fijo. Cobran una **Tarifa** acordada multiplicada por los **Trabajos/Monstruos** realizados ese mes.
- No tienen vacaciones, pero el sistema debe permitir **`renovarContrato()`** cuando su servicio ha sido satisfactorio.

----

### 3. Los Oficios (Clases Concretas)

Finalmente, debes implementar los roles espec√≠ficos que deambulan por Temeria:

- ‚öîÔ∏è **El Caballero:** Pertenece a la Corte. Porta un **Arma** distintiva (como una Espada Bastarda o una Lanza). Cuando trabaja, **patrulla las murallas** protegiendo el reino.
- ‚ú® **El Mago:** Pertenece a la Corte. Se le clasifica por su **Nivel de Magia** (entero). Cuando trabaja, **conjura hechizos** acordes a su nivel para proteger la corona.
- üí∞ **El Mercenario:** Es un Externo. Cobra por d√≠a. Cuando trabaja, **acepta encargos de escolta** o defensa de caravanas.
- üê∫ **El Brujo:** Es un Externo, un mal necesario. Pertenece a una **Escuela** (Lobo, Gato, Grifo...). Cuando trabaja, **medita y rastrea bestias** peligrosas.

----

### 4. La Prueba de Fuego (`GestionTemeria`)

Para demostrar que tu sistema funciona, debes convocar una asamblea (Clase Main) donde:

1. Reclutes una cuadrilla variada (un Array) con al menos:
    - *Vernon Roche* (Caballero).
    - *Triss Merigold* (Maga).
    - *Geralt de Rivia* (Brujo).
2. Pases revista a todos ellos:
    - Deben decirte qui√©nes son.
    - Debes ordenarles que trabajen.
    - Debes calcular cu√°nto oro debo pagarles este mes.
    - **¬°Importante!** Si es alguien de la corte, verifica si quiere vacaciones. Si es un externo, renueva su contrato. Para esto necesitar√°s usar `instanceof` y casting.

*¬°Hazlo bien, y ser√°s recompensado! Falla, y te enviaremos a las mazmorras con los nekkers.*

----

### Gu√≠a T√©cnica R√°pida

*Por si el decreto real te confunde, aqu√≠ tienes la traducci√≥n a "Lenguaje Java":*

1. **Herencia de 3 Niveles:** `Empleado` (Abuelo) -> `EmpleadoCorte`/`EmpleadoExterno` (Padres) -> `Caballero`/`Brujo`... (Nietos).
2. **Abstracci√≥n:** Las clases `Empleado`, `EmpleadoCorte` y `EmpleadoExterno` deben ser `abstract`. No queremos instanciar un "Empleado de Corte" gen√©rico, queremos un Caballero o un Mago.
3. **Polimorfismo:** En el Main, usa un `ArrayList<Empleado>`.
4. **Casting (`instanceof`):** En el bucle, tendr√°s que preguntar `if (e instanceof EmpleadoCorte)` para poder llamar al m√©todo `solicitarVacaciones()`, ya que la clase padre `Empleado` no conoce ese m√©todo.

----

No es preciso entregar esta actividad, en un mundo asolado por la inteligencia artificial no tiene sentido que os pida entregar esto como tarea evaluable. S√≠ que os animo a hacerla porque es un buen ejercicio para afianzar los conceptos de POO vistos en este cap√≠tulo, y va alineado con lo que preguntar√© en el examen del **segundo** semestre, pues est√° relacionado con todo el tema de POO / UML. Si alguien quiere compartir su soluci√≥n conmigo, estar√© encantado de verla y darle feedback, tanto en Java como en Kotlin (especialmente Kotlin, que es el futuro). Probablemente suba mi soluci√≥n a GitHub pr√≥ximamente, en Kotlin.

Por ajustarme al tema de la calificaci√≥n, s√≠ que subir√© un cuestionario en los pr√≥ximos d√≠as cuya calificaci√≥n corresponder√° a la contribuci√≥n de la UP07 a la evaluaci√≥n continua del m√≥dulo EDE.

## 6. Polimorfismo e Interfaces

El **polimorfismo** es otro de los pilares fundamentales de la Programaci√≥n Orientada a Objetos. La palabra "polimorfismo" proviene del griego y significa "muchas formas". En t√©rminos simples, el polimorfismo permite que una misma interfaz o m√©todo se comporte de diferentes maneras seg√∫n el objeto que lo est√© utilizando. Esto es especialmente √∫til cuando se trabaja con jerarqu√≠as de clases y herencia, ya que permite tratar objetos de diferentes clases de manera uniforme.

Sin embargo, el polimorfismo encuentra una limitaci√≥n cuando, por efecto de una hipot√©tica herencia m√∫ltiple, encontramos una ambig√ºedad. Vamos a verlo con un ejemplo sencillo. Supongamos que tenemos una clase base `Animal` y algunos de estos animales son `Mam√≠feros`.
Ahora, pensemos en un `Delfin`. Un delf√≠n **es un** `Mamifero`, pero tambi√©n **es un** animal `Acuatico`. Si quisi√©ramos modelar esto con herencia, nos encontrar√≠amos con un problema:

```text
    Animal
    /    \
 Mamifero  Acuatico
    \    /
    Delfin
```

Este esquema se conoce como el **"Problema del Diamante"**. Imagina que tanto `Mamifero` como `Acuatico` tienen un m√©todo con el mismo nombre, por ejemplo, `desplazarse()`.

- `Mamifero.desplazarse()` podr√≠a decir: "Me desplazo por tierra".
- `Acuatico.desplazarse()` podr√≠a decir: "Me desplazo por agua".

Cuando creamos un objeto `Delfin`, ¬øcu√°l de los dos m√©todos `desplazarse()` deber√≠a heredar? ¬øEl de `Mamifero` o el de `Acuatico`? Esta ambig√ºedad es la raz√≥n por la que **Java proh√≠be la herencia m√∫ltiple de clases**, lo mismo sucede en Kotlin. Una clase en Java solo puede `extends` de una √∫nica superclase.

### 6.1. La Soluci√≥n: Interfaces

Para resolver este problema, Java introduce el concepto de **interfaces**. Una interfaz es como un contrato que define un conjunto de m√©todos que una clase debe implementar. A diferencia de una clase (incluso abstracta), una interfaz no contiene estado (atributos) ni implementaci√≥n para sus m√©todos (aunque desde Java 8 pueden tener m√©todos `default` con implementaci√≥n).

La regla clave es:
> Una clase puede **extender** solo **una** superclase, pero puede **implementar** **m√∫ltiples** interfaces.

As√≠, podemos redise√±ar nuestro ejemplo de la siguiente manera:

- `Animal` sigue siendo nuestra clase base (posiblemente abstracta).
- `Mamifero` es una clase que `extends Animal`.
- `Acuatico` se convierte en una **interfaz** que define el comportamiento de "ser acu√°tico", como el m√©todo `nadar()`.

Ahora, la clase `Delfin` puede heredar su naturaleza de mam√≠fero y, al mismo tiempo, firmar el contrato para ser acu√°tico:

```java
// INTERFAZ: Define un contrato de comportamiento
public interface Acuatico {
    void nadar(); // Las clases que implementen Acuatico DEBEN definir este m√©todo
}

// CLASE ABSTRACTA PADRE
public abstract class Animal {
    protected String nombre;

    public Animal(String nombre) {
      this.nombre = nombre;
    }

    // Comportamiento com√∫n
    public void respirar() {
      System.out.println(nombre + " est√° respirando.");
    }

    // M√©todo que todas las subclases deben definir
    public abstract void emitirSonido();
}

// CLASE HIJA
public class Mamifero extends Animal {
    public Mamifero(String nombre) {
      super(nombre);
    }

    public void amamantar() {
      System.out.println(nombre + " est√° amamantando a sus cr√≠as.");
    }

    @Override
    public void emitirSonido() {
      System.out.println(nombre + " emite un sonido de mam√≠fero.");
    }
}

// CLASE QUE USA HERENCIA E INTERFACES
public class Delfin extends Mamifero implements Acuatico {

    public Delfin(String nombre) {
      super(nombre);
    }

    // Implementaci√≥n obligatoria del m√©todo de la interfaz Acuatico
    @Override
    public void nadar() {
      System.out.println(nombre + " est√° nadando elegantemente.");
    }

    // Sobrescritura del m√©todo de Animal/Mamifero para especializarlo
    @Override
    public void emitirSonido() {
      System.out.println(nombre + " hace clics y silbidos.");
    }
}
```

De esta forma, un `Delfin` hereda todo lo de `Mamifero` (que a su vez hereda de `Animal`) y adem√°s cumple con el contrato de `Acuatico`, resolviendo el problema del diamante de forma elegante.

### 6.2. Polimorfismo en Acci√≥n

Ahora que tenemos nuestra jerarqu√≠a, veamos el polimorfismo. Podemos crear una lista de `Animal` y a√±adir objetos de diferentes subclases. Aunque la lista es de tipo `Animal`, cada objeto se comportar√° seg√∫n su tipo real en tiempo de ejecuci√≥n.

```java
public class Zoologico {
    public static void main(String[] args) {
      // La lista es de tipo Animal, pero contiene objetos de clases hijas.
      Animal[] animales = new Animal[2];
      animales[0] = new Delfin("Flipper");
      animales[1] = new Mamifero("Simba"); // Un mam√≠fero gen√©rico (si no fuera abstracta)

      for (Animal animal : animales) {
        System.out.println("--- Procesando a " + animal.nombre + " ---");
        animal.respirar();
        animal.emitirSonido(); // ¬°POLIMORFISMO! Se llama al m√©todo de la clase real (Delfin o Mamifero)

        // Si queremos usar un m√©todo espec√≠fico de una subclase, necesitamos hacer un casting
        if (animal instanceof Delfin) {
            Delfin delfin = (Delfin) animal; // Casting: le decimos al compilador "conf√≠a en m√≠, esto es un Delfin"
            delfin.nadar();
        }
      }
    }
}
```

La salida de este programa ser√≠a:

```text
--- Procesando a Flipper ---
Flipper est√° respirando.
Flipper hace clics y silbidos.
Flipper est√° nadando elegantemente.
--- Procesando a Simba ---
Simba est√° respirando.
Simba emite un sonido de mam√≠fero.
```

Como puedes ver, la llamada a `animal.emitirSonido()` se comporta de forma diferente dependiendo de si el `animal` es un `Delfin` o un `Mamifero`. Esto es el polimorfismo: una misma llamada (`emitirSonido()`) tiene "muchas formas" de ejecutarse.

### 6.3. Ampliaci√≥n Kotlin (Interfaces y Polimorfismo)

Kotlin tambi√©n soporta interfaces y polimorfismo de manera similar a Java, pero con una sintaxis m√°s concisa. Aqu√≠ tienes el mismo ejemplo adaptado a Kotlin:

```kotlin
// INTERFAZ
interface Acuatico {
    fun nadar()
}
// CLASE ABSTRACTA PADRE
abstract class Animal(protected val nombre: String) {
    fun respirar() {
        println("$nombre est√° respirando.")
    }

    abstract fun emitirSonido()
}
// CLASE HIJA
open class Mamifero(nombre: String) : Animal(nombre) {
    fun amamantar() {
        println("$nombre est√° amamantando a sus cr√≠as.")
    }

    override fun emitirSonido() {
        println("$nombre emite un sonido de mam√≠fero.")
    }
}
// CLASE QUE USA HERENCIA E INTERFACES
class Delfin(nombre: String) : Mamifero(nombre), Acuatico {
    override fun nadar() {
        println("$nombre est√° nadando elegantemente.")
    }

    override fun emitirSonido() {
        println("$nombre hace clics y silbidos.")
    }
}
fun main() {
    val animales: Array<Animal> = arrayOf(Delfin("Flipper"), Mamifero("Simba"))

    for (animal in animales) {
        println("--- Procesando a ${animal.nombre} ---")
        animal.respirar()
        animal.emitirSonido() // POLIMORFISMO

        if (animal is Delfin) {
            animal.nadar() // No necesita casting expl√≠cito. Kotlin lo infiere.
        }
    }
} 
```

## Ampliaci√≥n Orden y Orens. Interfaces

El rey Foltest ha detectado que hay un abuso de las pociones m√°gicas por lo que obligar√° a todos los empleados internos y externos de Temeria a registrarse como usuarios de pociones. Para ello, ha decidido que tanto los empleados de la corte como los externos deben implementar una interfaz llamada `UsuarioPociones` para gestionar las siguientes cuestiones:

- `MAX_POCIONES`: Una constante que define el n√∫mero m√°ximo de pociones que un usuario puede llevar (valor 3). M√°s de tres pociones ser√≠a sospechoso de contrabando de objetos m√°gicos.
- `usarPocion()`: Un m√©todo que permite al usuario consumir una poci√≥n.
- `comprarPocion()`: Un m√©todo que permite al usuario comprar una siempre y cuando no haya alcanzado el l√≠mite m√°ximo.

Los √∫nicas clases de empleados autorizadas a usar pociones son los `Magos` y los `Brujos`, por lo que solo estas clases deben implementar la interfaz `UsuarioPociones`.

Deber√°s modificar las clases concretas correspondientes para llevar la cuenta del n√∫mero de pociones que cada usuario tiene y asegurarte de que no puedan comprar m√°s de las permitidas ni usar una poci√≥n si no tienen ninguna.

De nuevo esto cambia un poco entre Kotlin y Java. En Java no puedes definir atributos en una interfaz, solo constantes (atributos `static final`), mientras que en Kotlin puedes definir propiedades en una interfaz, pero no pueden tener estado (no puedes inicializarlas directamente, solo declararlas).

## Ampliaci√≥n Principios SOLID

Los principios SOLID son un conjunto de cinco principios de dise√±o de software orientado a objetos que buscan mejorar la calidad, mantenibilidad y escalabilidad del c√≥digo. Estos principios fueron popularizados por Robert C. Martin (tambi√©n conocido como "Uncle Bob") y son ampliamente utilizados en el desarrollo de software profesional. A continuaci√≥n, se describen brevemente cada uno de los principios SOLID:

1. **S - Principio de Responsabilidad √önica (Single Responsibility Principle - SRP):**
   - Una clase debe tener una √∫nica raz√≥n para cambiar, lo que significa que debe tener una sola responsabilidad o funci√≥n. Esto facilita la comprensi√≥n y el mantenimiento del c√≥digo.
2. **O - Principio de Abierto/Cerrado (Open/Closed Principle - OCP):**
   - Las entidades de software (clases, m√≥dulos, funciones, etc.) deben estar abiertas para la extensi√≥n, pero cerradas para la modificaci√≥n. Esto significa que puedes agregar nuevas funcionalidades sin alterar el c√≥digo existente, lo que reduce el riesgo de introducir errores.
3. **L - Principio de Sustituci√≥n de Liskov (Liskov Substitution Principle - LSP):**
   - Los objetos de una clase derivada deben poder sustituir a los objetos de la clase base sin alterar el correcto funcionamiento del programa. Esto asegura que las subclases mantengan el comportamiento esperado de la superclase.
4. **I - Principio de Segregaci√≥n de Interfaces (Interface Segregation Principle - ISP):**
   - Los clientes no deben verse obligados a depender de interfaces que no utilizan. En lugar de una interfaz grande y monol√≠tica, es mejor tener varias interfaces espec√≠ficas y peque√±as que se adapten a las necesidades de los clientes.
5. **D - Principio de Inversi√≥n de Dependencias (Dependency Inversion Principle - DIP):**
   - Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel; ambos deben depender de abstracciones. Adem√°s, las abstracciones no deben depender de los detalles; los detalles deben depender de las abstracciones. Esto promueve un dise√±o desacoplado y facilita la reutilizaci√≥n del c√≥digo.

Estos principios son fundamentales para el dise√±o de software orientado a objetos y ayudan a crear sistemas que son m√°s f√°ciles de entender, mantener y escalar con el tiempo. Aplicar los principios SOLID puede conducir a un c√≥digo m√°s limpio y robusto, lo que es especialmente importante en proyectos de software grandes y complejos.
