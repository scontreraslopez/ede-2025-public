<!-- markdownlint-disable MD029 MD033 -->

# UP06 Fases en el desarrollo y ejecución del software

## 1. Introducción

El desarrollo de software es un proceso complejo que implica varias fases, desde la concepción inicial hasta la entrega final y el mantenimiento continuo.

A nivel particular muchas veces empezamos *la casa por el tejado*, centrándonos en la codificación sin una planificación adecuada. Si bien esto es factible dentro del alcance (scope) de proyectos pequeños y bien definidos, como podría ser una actividad calificable, es inviable en proyectos de mayor envergadura. Además, en el ejercicio de la actividad profesional, antes de autorizarse un proyecto es necesario presentar una propuesta formal que detalle los beneficios del proyecto, sus riesgos, las fases del desarrollo, los recursos necesarios, los plazos y los costes asociados. Sin esta propuesta, el proyecto *muere antes de nacer*.

En esta unidad, vamos a levantar la vista del teclado para entender cómo se organiza todo esto. Aprenderemos a distinguir las diferentes etapas por las que pasa una aplicación, desde que es una simple idea en el bloc de notas hasta que se convierte en un producto final mantenible. Estudiaremos los roles que intervienen (porque rara vez trabajaréis solos) y las metodologías que nos ayudan a no perder el rumbo.

Pero antes de hablar de fases y metodologías, debemos definir con precisión el terreno de juego: **¿Qué es exactamente un proyecto de software y en qué se diferencia del trabajo diario (rutinario) de mantenimiento y resolución de incidencias?**

## 1.1. Concepto de proyecto de software

A menudo se abusa del término "proyecto" para referirse a cualquier tarea o conjunto de tareas. Sin embargo, en el ámbito del desarrollo de software, un proyecto se define por ciertas características clave. Según el **PMBOK** (Project Management Body of Knowledge), que es la referencia fundamental en gestión de proyectos (no sólo de software), un proyecto es:

- **Temporal**: Todo proyecto tiene un inicio y un fin definidos. El proyecto termina cuando se alcanzan los objetivos o cuando se cancela. No es un esfuerzo eterno.
- **Produce un resultado único**: El objetivo es crear un producto, servicio o resultado específico (una App móvil, una migración de base de datos, un módulo de facturación) que no existía antes.

> [!NOTE]
> Pensad en vuestro **Proyecto Intermodular**. Tiene una fecha de inicio (cuando presentáis la propuesta) y una fecha de fin (la defensa ante el tribunal). El resultado es una aplicación única. Eso es un proyecto.

Sin embargo, el desarrollo de software tiene una particularidad: **la intangibilidad**. A diferencia de construir un puente, en el software los cambios son más fáciles de realizar (o eso parece), lo que a menudo lleva a una falsa sensación de flexibilidad que hace descarrilar a los proyectos cuando los requisitos cambian constantemente. Por eso, es crucial gestionar bien los requisitos y expectativas desde el principio.

## 1.2. Diferencia entre proyecto y operación (servicios)

Aquí es donde mucha gente que está empezando en el mundo del desarrollo de software se confunde. El software que ya se ha sido desarrollado, probado y entregado al cliente (puesto en producción, acostumbraros a este término) entra en una fase de **operación** o **servicios**. El proyecto ha concluido.

> [!NOTE]
> Tristemente, en el software muchos proyectos se entregan a medio cocinar por diversos motivos (mala gestión, cambios de requisitos, falta de recursos, cuestiones políticas, etc.) y se convierten en un "proyecto eterno" que se va resolviendo *sottovoce* en la fase de operación, lo que no es correcto. No es lo que debería ser, pero es una realidad el sector y a nadie ayuda ignorarla.

¿Qué ocurre (o debería ocurrir) al día siguiente? Empieza la **Operación** o el ciclo de vida del Servicio.

- Proyecto: "Vamos a construir la nueva web corporativa". (Hay incertidumbre, diseño, construcción).
- Operativa/Proceso: "Vamos a monitorizar que el servidor de la web no se caiga y a realizar copias de seguridad diarias". (Es repetitivo, estable y continuo).

Esta distinción es vital porque las **Metodologías de Desarrollo** (que veremos más adelante, como Scrum o Cascada) están diseñadas principalmente para la fase de **Proyecto** (creación y cambio), mientras que existen otros marcos de trabajo (como ITIL o Kanban en ciertos contextos) más orientados a la gestión del servicio y el flujo continuo de trabajo.

### 1.3. El Mantenimiento del Software

El **mantenimiento** es una de las fases críticas del desarrollo de aplicaciones. Y no es para menos: se estima que **entre el 60% y el 80% del coste total** de una aplicación a lo largo de su vida se gasta en mantenimiento, no en el desarrollo inicial.

El mantenimiento **no es solo arreglar cosas rotas**. Cuando estéis trabajando, os llegarán "tickets" o incidencias de mantenimiento que pueden ser de varios tipos:

1. **Mantenimiento Correctivo (El "Bug"):** El software tiene un fallo. Algo no funciona como debería. *Ejemplo: Al pulsar "Imprimir", la aplicación se cierra inesperadamente.* La tarea es diagnosticar y reparar. Es algo que ya existía y que en teoría se aceptó en la entrega. *Se suponía que funcionaba* pero no lo hace. Por lo general, y salvo que sea un cambio mastodóntico, este tipo de mantenimiento se resuelve por el equipo de operación o soporte.
2. **Mantenimiento Adaptativo (El Entorno cambia):** El software funciona bien, pero el entorno ha cambiado y debemos adaptarlo. *Ejemplo: Google Chrome actualiza su política de seguridad, o cambiamos el servidor de Windows a Linux, o sale una nueva ley de protección de datos.* De nuevo, según la magnitud del cambio, este mantenimiento puede ser realizado por el equipo de operación o puede requerir un pequeño proyecto de desarrollo para adaptarse.
3. **Mantenimiento Perfectivo (Mejora):** El usuario quiere "algo más" o "algo mejor". No es un error, es una evolución. *Ejemplo: Que el sistema tarde 1 segundo en buscar en lugar de 5, o añadir un botón para exportar a PDF.* En general, este tipo de mantenimiento puede requerir un pequeño proyecto de desarrollo, dependiendo de la envergadura del cambio solicitado.
4. **Mantenimiento Preventivo (Salud a largo plazo):** Nadie se ha quejado, pero nosotros sabemos que hay que actuar para evitar problemas futuros. *Ejemplo: Refactorizar código sucio (limpiar código desordenado) para que sea más fácil de leer en el futuro, o actualizar librerías antes de que queden obsoletas.*
5. **Incidencias de datos (Estrictamente no es mantenimiento del software):** A veces, el problema no está en el software, sino en los datos. *Ejemplo: Un usuario ha introducido un dato erróneo que provoca un fallo del que no hay manera de salir.* Aquí, la solución puede ser corregir los datos sin tocar el software. Esto por lo general lo hace el equipo de soporte o administración de datos, en la fase de operación. El tener que hacer este tipo de operaciones puede ser indicador de que el software necesita mejoras (mantenimiento perfectivo) para validar mejor los datos en el futuro. Además, esta es una de las tareas donde hay que ir con cuidado extremo para no corromper datos legítimos.

¿Y dónde está la frontera? En mi experiencia, la línea divisoria entre mantenimiento y proyecto suele ser la **complejidad y el alcance del cambio**. Pensad que muchas veces durante la fase de desarrollo de proyecto se arman grandes equipos para hacer cambios significativos (y se incurre en muchos costes), una vez que el software se entrega este equipo se disuelve (*disband* en inglés técnico). El software pasa a ser gestionado por un equipo más pequeño y especializado en mantenimiento y operación, tampoco es raro, sobre todo en aplicaciones no excesivamente críticas o complejas, que el equipo de soporte y mantenimiento se encargue del mantenimiento de varias aplicaciones a la vez. Esto puede ser muy diferente en PYMES o en grandes corporaciones, también según el sector, en mi experiencia se dan los siguientes escenarios típicos:

- **PYMES o Startups:** El equipo de desarrollo inicial suele encargarse del mantenimiento. Aquí no hay mucha distinción entre proyecto y operación, y el mismo equipo hace ambas cosas. Suele paralelizar el desarrollo de nuevas funcionalidades (o aplicaciones/productos) con el mantenimiento.
- **Grandes Corporaciones:** Suele haber equipos separados para desarrollo de nuevos proyectos y para mantenimiento/operación. El equipo de mantenimiento puede estar subdividido según el tipo de mantenimiento (correctivo, adaptativo, etc.) o según las aplicaciones (o tecnologías) que gestionan. El mantenimiento además se organiza en niveles (levels), donde el primer nivel atiende las incidencias más simples y las más complejas se escalan a niveles superiores o al equipo de desarrollo original. En las grandes corporaciones distinguimos además dos subtipos:
  - **Sector Crítico (Banca, Sanidad, etc.):** Aquí el mantenimiento es extremadamente riguroso y regulado. Se aplican estrictos controles de calidad, pruebas y auditorías para garantizar que los cambios no introducen riesgos.
  - **Sector No Crítico:** Aunque el mantenimiento sigue siendo importante, puede ser más flexible y menos regulado.

También en la naturaleza de la empresa hay ciertas diferencias, según el que sea su negocio core:

- **Empresas de Software (ISVs):** El mantenimiento es una parte fundamental del negocio. Se gestionan versiones, parches y actualizaciones regularmente con equipos internos dedicados.
- **Empresas No Tecnológicas:** El mantenimiento puede ser visto más como un coste necesario. A menudo se externaliza a proveedores especializados.

A las aplicaciones a veces se les denomina **sistemas** cuando están en producción, para diferenciarlas del software en desarrollo. Por ejemplo, "el sistema de gestión de clientes" o "el sistema de facturación". Estrictamente hablando, el sistema incluye no solo el software, sino también los datos, la infraestructura (servidores, redes) y los procesos asociados. A veces un sistema puede estar compuesto por varios programas o aplicaciones que interactúan entre sí.

También existe una frontera difusa entre lo que se considera una **aplicación** y un **producto**. Una aplicación (*el software*) se convierte en producto cuando se comercializa y se vende a múltiples clientes, con soporte, actualizaciones y posiblemente personalizaciones. Un producto suele tener un ciclo de vida más largo y requiere una gestión más formalizada, por ejemplo no puedes retirarlo sin más esto debe (o debería) gestionarse en una fase denominada *sunset*. Por su parte, una **solución** es un conjunto integrado de productos y servicios que abordan una necesidad específica del cliente o del mercado. Por ejemplo, una solución de gestión empresarial puede incluir un ERP, un CRM y servicios de consultoría. Finalmente, un **servicio** es una oferta intangible que proporciona valor al cliente sin la transferencia de propiedad de un producto físico. En el contexto del software, un servicio puede ser una aplicación basada en la nube (SaaS), soporte técnico, formación o consultoría.

### 1.4. La necesidad de la Ingeniería del Software

Antiguamente (y lamentablemente en algunos sitios todavía hoy), se programaba con el enfoque *"Code & Fix"* (Codificar y Corregir): escribir código rápido y arreglar los errores a medida que salían. Esto provocaba lo que se conoció como la **Crisis del Software**: proyectos fuera de presupuesto, entregas tardías, software de mala calidad y código imposible de mantener (el famoso "código espagueti").

> [!NOTE]
> A esto también se le llama el enfoque *"Cowboy Coding"*, donde los desarrolladores trabajan de manera independiente sin seguir procesos o estándares, lo que a menudo conduce a resultados desastrosos en proyectos grandes o complejos. Su lema es *tested in production* (probar en producción).

<img src="image.png" alt="Cowboy Coding" width="150" height="150">

Para solucionar esto, aplicamos la **Ingeniería**: un enfoque sistemático, disciplinado y cuantificable. Al igual que un ingeniero civil no empieza a poner ladrillos sin un plano y un estudio de cargas, un desarrollador de software profesional (vosotros futuros DAM/DAW) necesita:

1. **Fases claras** (Ciclo de vida).
2. **Métodos de trabajo** (Metodologías).
3. **Herramientas adecuadas** (Entornos de Desarrollo, Control de Versiones, etc.).

## 2. El Ciclo de Vida del Desarrollo de Software (SDLC)

Una vez tenemos claro que vamos a afrontar un **proyecto** (algo temporal con un resultado único), necesitamos un mapa. No podemos empezar a escribir código a lo loco esperando que salga bien. Aquí es donde entra el concepto de **Ciclo de Vida de Desarrollo de Software** (o **SDLC**, por sus siglas en inglés *Software Development Life Cycle*).

El SDLC describe **el camino que sigue el software desde que nace como una idea hasta que muere o se retira**. El currículo oficial establece unas fases canónicas que debemos conocer: Análisis, Diseño, Codificación, Pruebas, Documentación, Explotación y Mantenimiento.

> [!IMPORTANT]
> **Concepto clave para examen:**
> No confundáis el **Ciclo de Vida (Fases)** con la **Metodología (Modelo)**.
>
> - Las **Fases** son las tareas que *hay* que hacer (Analizar, Diseñar, Codificar...). Son el "QUÉ".
> - La **Metodología** es *cómo* ordenamos y gestionamos esas tareas (¿Hacemos todo el análisis al principio? ¿O analizamos un poco, codificamos y volvemos a analizar?).
>
> En este apartado veremos las **Fases Clásicas** que, de una forma u otra, siempre están presentes en cualquier desarrollo profesional.

### 2.1. Fase de Análisis de Requisitos (El "QUÉ")

Es la fase más crítica y, paradójicamente, la más olvidada por los programadores noveles. El objetivo es determinar **qué** debe hacer el software, no cómo lo hará. Si fallamos aquí, construiremos el producto equivocado, y no importa lo bien programado que esté: si no sirve para lo que el usuario necesita, es un fracaso.

Aquí el analista se reúne con los **Stakeholders** (interesados: clientes, usuarios finales, jefes...) para realizar una "toma de requisitos". El resultado de esta fase suele ser un documento llamado **ERS** (Especificación de Requisitos Software) o, en metodologías ágiles, un conjunto de **Historias de Usuario**.

> [!NOTE]
> A veces al **ERS** se le llama **SRS** (Software Requirements Specification) en inglés, o **SRD** (Software Requirements Document/Dossier).

Debemos distinguir dos tipos de requisitos fundamentales:

1. **Requisitos Funcionales:** Describen lo que el sistema debe **hacer**. Son comportamientos observables y funciones del negocio.
    - *Ejemplo:* "El sistema debe permitir dar de alta un nuevo cliente", "El sistema debe generar una factura en PDF", "Al pulsar el botón rojo, se debe enviar un email de confirmación".
2. **Requisitos No Funcionales (o de Calidad):** Describen **cómo** debe comportarse el sistema. Son restricciones o cualidades técnicas.
    - *Ejemplo:* "El sistema debe responder en menos de 2 segundos" (Rendimiento), "El sistema debe cumplir la ley GDPR" (Legal), "La contraseña debe almacenarse encriptada" (Seguridad), "Debe funcionar en tablets Android antiguas" (Compatibilidad), "Debe soportar 10.000 usuarios concurrentes" (Escalabilidad).

> [!NOTE]
> **La regla del 1-10-100:**
> Corregir un error en la fase de Análisis cuesta **1€** (basta con borrar una línea en el documento de Word). Si ese error pasa desapercibido y llega a Desarrollo, cuesta **10€** corregirlo (hay que reescribir código). Si llega a Producción y el cliente lo ve, el coste se dispara a **100€** (pérdida de reputación, migración de datos corruptos, parches de urgencia en fin de semana...). **Analizad bien antes de picar código.** Si en alguna especificación detectáis un requisito ambiguo o contradictorio, parad y preguntad, no deis nada por supuesto que luego viene el llanto y el crujir de dientes.

Los analistas más noveles cometen algunos pecados típicos que os comento para que los evitéis, o al menos sepáis identificarlos:

- **No involucrar a los usuarios finales:** Hablar solo con los jefes o *sponsors* (el mecenas del proyecto) puede llevar a malentendidos. Los usuarios son los que realmente usan el sistema.
- **Requisitos vagos o ambiguos:** Frases como "El sistema debe ser rápido" o "La interfaz debe ser intuitiva" son subjetivas. Hay que cuantificar y especificar. Este es uno de los más comunes. Dice la teoría de requisitos que estos deben ser **SMART**: Específicos (Specific), Medibles (Measurables), Alcanzables (Achievables), Relevantes (Relevants) y con un Tiempo definido (Time-bounds). Ejemplo: *La página de inicio debe cargar en menos de 2 segundos con una conexión 4G.*
- **No gestionar los cambios de requisitos:** Los requisitos pueden cambiar (y suelen hacerlo). Hay que tener un proceso para gestionar estos cambios y comunicar su impacto en tiempo y coste.
- **No priorizar requisitos:** No todos los requisitos tienen la misma importancia. Hay que identificar cuáles son críticos y cuáles son "buenos de tener" para gestionar el alcance del proyecto.
- **No documentar adecuadamente:** Un requisito no documentado es un requisito olvidado. Hay que dejar constancia escrita (o en herramientas de gestión de requisitos) de todo lo acordado.
- **No validar los requisitos con los stakeholders:** Antes de pasar a la siguiente fase, es crucial revisar y aprobar los requisitos con todas las partes interesadas para asegurarse de que todos están alineados.
- **No considerar requisitos no funcionales:** A menudo se centran solo en los funcionales, pero los no funcionales (rendimiento, seguridad, usabilidad) son igual de importantes para el éxito del proyecto.
- **No analizar el contexto del sistema:** Entender el entorno en el que operará el software (hardware, otros sistemas, usuarios) es vital para definir requisitos realistas.
- **No considerar restricciones técnicas o de negocio:** A veces hay limitaciones (presupuesto, tecnología existente, regulaciones) que afectan los requisitos y deben ser tenidas en cuenta desde el principio.
- **No usar técnicas adecuadas de elicitation:** Hay muchas técnicas para obtener requisitos (entrevistas, cuestionarios, talleres, prototipos). Usar solo una puede limitar la calidad y cantidad de requisitos obtenidos.
- **Cruzar la frontera hacia el diseño:** A veces los analistas empiezan a pensar en "cómo" implementar algo en lugar de "qué" se necesita. Esto puede llevar a soluciones prematuras y limitadas. Por ejemplo, decir "Usaremos una base de datos SQL" en lugar de "El sistema debe almacenar datos de clientes de forma persistente". También puede ser que un stakeholder te exija una solución técnica específica pues diversas cuestiones (por ejemplo la empresa ya tiene licencias de un software concreto), en ese caso debes documentar esa restricción técnica como un requisito no funcional.

Para escribir los requisitos hay diversas técnicas y formatos, desde documentos formales hasta herramientas de gestión de requisitos (siendo la más conocidas **IBM Rational DOORS** - más waterfall o **Jira** - muy popular en metodologías Ágiles) o incluso diagramas UML (casos de uso). Lo importante es que sean claros, completos y comprensibles para todos los involucrados. En determinados contextos también es fundamental la trazabilidad de requisitos, es decir, poder seguir el rastro de cada requisito desde su origen hasta su implementación y pruebas.

Uno de los formatos más populares en metodologías ágiles es la **Historia de Usuario**, que se escribe desde la perspectiva del usuario final y sigue la estructura:

```text
Como [tipo de usuario], quiero [acción o funcionalidad] para [beneficio o valor].
```

Ejemplo: *Como usuario registrado, quiero poder restablecer mi contraseña para recuperar el acceso a mi cuenta en caso de olvido.*

Aquí, trabajaremos mucho con **UML** (Lenguaje Unificado de Modelado) para representar requisitos funcionales mediante **Diagramas de Casos de Uso**, que visualizan las interacciones entre los usuarios (actores) y el sistema. Además del diagrama, cada caso de uso suele ir acompañado de una descripción textual que detalla el flujo normal y alternativo de eventos. Craig Larman, en su libro *Applying UML and Patterns*, es una referencia excelente para entender cómo modelar requisitos con UML.

**Debate de Expertos: El caso del "Login":**

Este bloque es considerado de ampliación y puede ser controvertido (opinionated). Lo incluyo porque es un tema recurrente en análisis de requisitos y puede generar debate en clase.

Existe una regla de oro en el análisis de requisitos (defendida por autores como Craig Larman): Un Caso de Uso debe aportar valor real al negocio. *¿Alguien compra una aplicación solo para poder introducir su usuario y contraseña?* Evidentemente no. Lo hacen para comprar, gestionar datos o comunicarse. El "Login" es solo un peaje de seguridad, una barrera necesaria, pero no un objetivo en sí mismo.

¿Cómo lo gestionamos entonces? Aunque teóricamente es una restricción de seguridad (Requisito No Funcional), en la práctica debemos implementarlo y consume tiempo. Además tiene entidad de funcionalidad propia y no es exclusivamente transversal. Por eso:

- En UML se suele modelar el "Login" como un **sub-caso de uso** o una **extensión** de los casos de uso principales que requieren autenticación.
- Como Requisito de Seguridad (no funcional): "El sistema debe restringir el acceso a usuarios identificados".
- Como Historia de Usuario con Valor: Buscando por qué es necesario. Ejemplo: "Como usuario, quiero identificarme para proteger mis transacciones personales." (Aquí el valor es la Privacidad).

### 2.2. Fase de Diseño (El "CÓMO")

Una vez sabemos qué quieren, definimos cómo vamos a construirlo. Es el plano del arquitecto antes de llamar a los albañiles. En esta fase se toman decisiones tecnológicas y estructurales que serán difíciles de cambiar después. Se suele dividir en dos niveles:

1. **Diseño de Alto Nivel (Arquitectura):** Se decide la estructura global del sistema.

- ¿Qué tecnologías usaremos? (Lenguajes, Frameworks).
- ¿Qué sistema gestor de base de datos? (MySQL, Oracle, MongoDB).
- ¿Cómo se comunicarán las partes? (Arquitectura Cliente-Servidor, Microservicios, Monolito).
- ¿Dónde se alojará? (Servidores propios *On-premise* o en la Nube tipo AWS/Azure).

2. **Diseño de Bajo Nivel (Detalle):** Se baja al barro para especificar los componentes.

- **Diseño de Datos:** Modelo Entidad-Relación, definición de tablas y claves (lo veréis a fondo en el módulo de BBDD).
- **Diseño de Clases y Objetos:** Diagramas UML de clases, definiendo atributos y métodos (lo veremos en las unidades 5 y 6).
- **Diseño de Interfaz (UI/UX):** Prototipos de las pantallas (Mockups o Wireframes) para definir la navegación del usuario.

> [!NOTE]
> Ojo aquí estamos hablando exclusivamente de SDLC que no se corresponde estrictamente con el ciclo de vida del proyecto. El proyecto envuelve al SDLC e incluye otras actividades como gestión de riesgos, comunicación, calidad, etc. Uno de los primeros entregables que hace el jefe de proyecto es el **Plan de Proyecto**, que detalla cómo se gestionarán todas estas áreas. También suele incluir un **Plan de Gestión de Requisitos** que define cómo se capturarán, documentarán y gestionarán los requisitos a lo largo del proyecto y una estimación inicial del **Alcance** (Scope) y **Coste** del proyecto.
>Cada fase incurre en unos costes y recursos específicos que deben ser planificados, monitorizados, controlados y autorizados. Las diferentes metodologías de proyectos incorporan una serie de hitos (milestones) que marcan la finalización de fases o entregables clave, y que sirven para evaluar el progreso y decidir si se continúa, se ajusta o se detiene el proyecto.
>La **estimación** del coste y tiempo de cada fase es fundamental para la planificación global del proyecto, además de ser una mezcla entre arte y ciencia de la que se han escrito libros enteros. La del tiempo es especialmente difícil, ya que los desarrolladores tienden a ser optimistas y subestiman el tiempo necesario (el famoso *optimism bias*), además del mito del hombre-mes (*Brooks' Law*) *More software projects have gone awry for lack of calendar time than for all other causes combined* (Frederick P. Brooks, *The Mythical Man-Month*).

A esta fase no se le suele dedicar tiempo suficiente y mucho me temo que es un problema que se va a agravar. En general las personas no estamos hechas para el pensamiento abstracto y el diseño estructurado, preferimos "ensuciarnos las manos" programando y ya ir pensando sobre la marcha. Esto es especialmente así en las personas con poca experiencia, que efectivamente necesitan construir esa intuición de diseño que solo se adquiere con la práctica. Con el advenimiento de la programación rápida, low-code y las herramientas visuales, esta fase puede verse tentada a ser saltada o minimizada aún más. Es un grave error. Si diseñáis mal la base de datos (por ejemplo, no normalizando correctamente las tablas), luego vuestro código SQL será una pesadilla de mantener. **Unas horas de diseño ahorran semanas de programación.** También a veces no se hace lo suficiente por entender el problema que se quiere resolver. Si no se comprende bien el dominio del problema, es imposible diseñar una solución adecuada, *yo soy informático a mi no me cuentes de ingeniería/banca/salud...* no vale. Hay que empaparse del negocio, hablar con los usuarios, entender sus flujos de trabajo y sus dolores (pain points). Esto es más así cuanta más responsabilidad tengáis dentro del proyecto y es una cualidad que si cultiváis os hará destacar.

### 2.3. Fase de Codificación o Implementación (La "CONSTRUCCIÓN")

Es la fase que, por lo general, más motiva al perfil técnico: **programar**. Aquí traducimos los documentos de diseño a un lenguaje de programación.

- Se escriben las clases, funciones, métodos y scripts.
- Se configuran las conexiones a bases de datos y APIs.
- Se utilizan las **Herramientas de Desarrollo** (IDEs como IntelliJ/Eclipse/VSCode) y Sistemas de Control de Versiones (Git), que es el core que hemos estado trabajando en este módulo profesional.

El resultado de esta fase es el **Código Fuente** (legible por humanos) que luego, dependiendo del lenguaje, se compilará o interpretará para ser ejecutado por la máquina.

> [!WARNING]
> En entornos profesionales, no vale con que "funcione". El código debe ser **limpio** (*Clean Code*), estar comentado, documentado y seguir los estándares de estilo del equipo. Escribir código críptico que solo tú entiendes es garantía de problemas futuros y roces con los compañeros que tengan que mantener tu trabajo. Además, cada vez más se pasan por herramientas automáticas de análisis estático (SonarQube, ESLint, etc.) que miden la calidad del código y detectan "code smells" (malas prácticas), si hacéis código chapucero, estas herramientas os lo van a señalar. Y si te acuerdas de git, con el git blame, cualquiera puede ver quién escribió cada línea de código y cuándo, así que no hay excusas para no hacer un buen trabajo.

### 2.4. Fase de Pruebas (Testing)

Antes de entregar, hay que verificar que el software cumple con los requisitos y que no falla. El objetivo del testing es encontrar fallos (**bugs**) antes que el cliente.

Existen muchos niveles de pruebas (que corresponden también a otro de los resultados de aprendizaje del módulo), pero a nivel general podemos distinguir:

1. **Pruebas Unitarias:** ¿Funciona este método o función de forma aislada? (Las suele hacer el propio programador).
2. **Pruebas de Integración:** ¿Funcionan bien el módulo A y el módulo B cuando se conectan entre sí?
3. **Pruebas de Sistema:** ¿Funciona la aplicación completa globalmente?
4. **Pruebas de Aceptación:** ¿Está el cliente conforme con el resultado? (Aquí es donde el cliente da el "Visto Bueno" formal).

> [!NOTE]
> **El sesgo del desarrollador:**
> Es muy difícil encontrar tus propios errores porque subconscientemente pruebas el software por el "camino feliz" (donde sabes que funciona). Por eso, en equipos grandes existe la figura del **QA (Quality Assurance)** o Tester, una persona dedicada exclusivamente a intentar "romper" la aplicación. Además muchas veces el desarrollador tiene presión por entregar y esto va justo en contra de hacer unas pruebas exhaustivas. En equipos pequeños, al menos es recomendable que otro desarrollador revise tu código y haga pruebas cruzadas.

Esta fase es crítica para la calidad del software y, junto con la documentación, la primera víctima de los plazos ajustados. Sin embargo, un software mal probado es una bomba de relojería que puede explotar en producción, causando pérdidas económicas y de reputación. Aquí el jefe del proyecto debe ser firme y no permitir recortes en pruebas, esta cualidad de resistir la presión es fundamental en su rol y que no es para nada sencilla de cultivar ni encaja en todos los tipos de personalidades.

Frameworks de pruebas automatizadas (JUnit, Selenium, etc.) son cada vez más comunes para agilizar esta fase y asegurar que las pruebas se pueden repetir fácilmente con cada nueva versión del software. También existen metodologías como TDD (Test-Driven Development) donde se escriben las pruebas antes que el código, forzando a pensar en los requisitos desde el punto de vista de la prueba, aunque de nuevo pueden pervertirse en un ritual sin sentido si no se entienden bien sus fundamentos y se acaba escribiendo código para pasar pruebas en lugar de código que resuelva el problema real.

Uno de los puntos a mi juicio más complicados de organizar en las pruebas es el tema de las **bases de datos**. En aplicaciones que dependen de bases de datos, es crucial tener un entorno de pruebas que refleje fielmente el entorno de producción, pero sin usar datos reales por razones de privacidad y seguridad. Aquí entran en juego conceptos como **mocks** (simulaciones de datos), **stubs** (versiones simplificadas de componentes) y **fixtures** (conjuntos predefinidos de datos para pruebas). Herramientas como **DBUnit** o **Flyway** pueden ayudar a gestionar estos entornos y asegurar que las pruebas son consistentes y reproducibles. Cuando la lógica de negocio se fragmenta entre la aplicación y la base de datos (por ejemplo, con procedimientos almacenados), las pruebas pueden complicarse aún más, requiriendo estrategias específicas para validar tanto el código de la aplicación como el de la base de datos, esto ocurre cuando algunos desarrolladores se sienten más cómodos escribiendo lógica SQL que lógica en el lenguaje de programación principal. A veces se *defiende* esta práctica como una forma de optimizar el rendimiento, pero puede llevar a problemas de mantenimiento y pruebas si no se gestiona adecuadamente. Es algo que hay que tener muy en cuenta en el diseño y desarrollo del software. En mi experiencia, la clave está en mantener una **separación clara de responsabilidades** y evitar mezclar demasiada lógica de negocio en la base de datos, salvo casos muy específicos donde el rendimiento lo justifique, además que los **ORM** (Object-Relational Mapping) modernos permiten abstraer gran parte de la interacción con la base de datos, facilitando las pruebas y el mantenimiento y cada vez son más eficientes.

### 2.5. Fase de Documentación

Aunque el currículo la lista a veces como una fase separada, la documentación es una actividad **transversal** que debe ocurrir durante todo el ciclo.

- Documentación Técnica: Para los desarrolladores (JavaDoc, diagramas, comentarios en código).
- Documentación de Usuario: Manuales de usuario, guías de instalación, ayudas online.

Un software sin documentación es una "caja negra" imposible de mantener. La documentación debe ser clara, actualizada y accesible. Hoy en día, muchas veces se usa documentación en línea (wikis, portales internos) que facilita su actualización y acceso. Herramientas como **Swagger** para documentar APIs REST son muy populares en el desarrollo moderno, otras como **Confluence** o **ReadTheDocs** permiten crear documentación colaborativa y bien estructurada. Muchos proyectos open source usan **Markdown** para escribir documentación técnica que se almacena junto al código en repositorios como GitHub.

También hay herramientas que generan documentación automáticamente a partir del código fuente, como **Doxygen** o **Sphinx**, lo que ayuda a mantener la documentación sincronizada con el código. Ayudan a corregir el problema típico de que la documentación quede obsoleta tras varias iteraciones de desarrollo.

Cuando trabajéis en equipo, es fundamental definir **estándares de documentación** desde el principio para asegurar coherencia y calidad. Por ejemplo, naming conventions, semantic git, semantic versioning, estructura de carpetas para documentos, formatos aceptados (PDF, HTML, etc.) y responsabilidades (quién documenta qué). Por último, comentar que existen herramientas que generan artefactos de documentación a partir de modelos UML, como **Enterprise Architect** o **Visual Paradigm**, que pueden ser útiles para mantener la documentación técnica alineada con el diseño del sistema. Más cercana al código, pero todavía en UML, encontramos herramientas como **PlantUML** que permiten crear diagramas UML a partir de texto, facilitando su integración en la documentación, o **Mermaid.js** para diagramas más simples. Mermaid es especialmente útil para documentación en Markdown, ya que permite incluir diagramas directamente en archivos README.md o wikis como la de GitHub.

Durante este curso trabajaréis con **JavaDoc** para documentar el código Java, existen herramientas similares para otros lenguajes como **Docstrings** en Python o **JSDoc** en JavaScript, o **KDoc** para Kotlin. Esta es una cuestión en la que las herramientas de inteligencia artificial pueden ayudar mucho en el futuro, generando documentación automática a partir del código y comentarios, pero siempre es recomendable revisar y ajustar esta documentación generada para asegurar su precisión y claridad.

### 2.6. Fase de Despliegue o Implantación

Es el momento de la verdad. El software sale del entorno de desarrollo (nuestros ordenadores) y se instala en el entorno real de uso.

- **Entorno de Producción:** Es el servidor real donde trabajan los usuarios y donde están los datos reales. ¡Aquí está prohibido hacer pruebas!
- **Puesta en producción:** Puede requerir migrar datos antiguos, configurar servidores web, abrir puertos en el firewall, etc.

> [!TIP]
> **"En mi máquina funcionaba":**
> Este es el problema más común en el despliegue. Tu ordenador tiene una configuración específica, librerías instaladas y rutas de archivos que quizás el servidor del cliente no tiene. Para evitar esto, hoy en día se usan tecnologías como **Docker** (contenedores), que permiten empaquetar la aplicación con todo lo que necesita para funcionar igual en todas partes.

Para esta fase existen diversas estrategias de despliegue:

- **Despliegue en Fase:** Se despliega primero a un grupo pequeño de usuarios (beta testers) para validar que todo funciona antes de abrirlo a todos.
- **Despliegue Azul/Verde:** Se mantienen dos entornos idénticos (azul y verde). El tráfico se dirige al entorno activo (azul), mientras se actualiza el otro (verde). Una vez validado, se cambia el tráfico al verde.
- **Despliegue Continuo:** En entornos DevOps, se automatiza el despliegue con herramientas como Jenkins, GitLab CI/CD o GitHub Actions, permitiendo actualizaciones frecuentes y rápidas.
- **Canary Releases:** Similar al despliegue en fase, pero se dirige un pequeño porcentaje del tráfico al nuevo despliegue para monitorear su comportamiento antes de hacer el cambio completo. Esto lo hacen grandes empresas como Netflix o Google para minimizar riesgos.

Además del entorno de producción, es recomendable tener, si la envergadura del proyecto lo justifica los siguientes entornos:

- **Entorno de Desarrollo:** Donde los desarrolladores escriben y prueban el código. Es el entorno local o compartido donde se hacen los commits.
- **Entorno de Pruebas:** Donde se realizan pruebas de calidad, integración y aceptación antes de pasar a producción. Típicamente incorporará CI/CD desde la rama de desarrollo (*develop*).
- **Entorno de Staging (preproducción):** Una réplica casi idéntica del entorno de producción donde se hacen pruebas finales antes del despliegue real. Aquí se prueban despliegues completos y migraciones de datos. A veces se carga con datos de producción anonimizados para simular el entorno real.
- **Entorno de User Acceptance Testing (UAT):** Donde los usuarios finales validan que el software cumple con sus expectativas antes de la puesta en producción. Este entorno puede ser similar al de staging, pero con acceso restringido a los usuarios clave. Si se acepta el software en UAT, se procede al despliegue en producción. Ojo, no siempre existe este entorno, depende de la criticidad del proyecto y los recursos disponibles, hay proyectos que necesitan una validación formal por parte del cliente antes de la puesta en producción es precisamente para eso. Empresas como Netflix presumen de hacer cientos de despliegues diarios gracias a sus avanzadas prácticas de DevOps y automatización, en estos casos evidentemente el entorno de UAT ha sido sustituido por pruebas automatizadas y monitorización en tiempo real dentro de la pipeline de despliegue continuo.

### 2.7. Fase de Mantenimiento y Explotación

Como detallamos en la unidad anterior, una vez desplegado, el software entra en fase de operación. Aquí se monitorea su funcionamiento, se corrigen errores detectados por los usuarios y se evoluciona la aplicación. Recordad: el ciclo no es una línea recta que termina, es una rueda que vuelve a girar con cada nueva versión.

En esta fase se suele usar un sistema de gestión de incidencias (Jira, ServiceNow, etc.), *ticketing*, para registrar y priorizar los problemas reportados por los usuarios. También se planifican nuevas funcionalidades basadas en feedback y cambios en el negocio. Es fundamental que el equipo de soporte y mantenimiento tenga acceso a toda la documentación generada en fases anteriores para entender el sistema y resolver problemas eficientemente, además de actualizarla conforme se realizan cambios, sino puede ser catastrófico para hacer evolucionar el software, y, a mi juicio, la causa principal de que muchos sistemas legados sean imposibles de mantener y se abandonan.

## 3. Modelos de Ciclo de Vida y Metodologías

Si las **fases** (que vimos en el punto anterior) son los **ingredientes** de la receta (huevos, harina, azúcar), la **metodología** es la **receta** propiamente dicha. Con los mismos ingredientes, puedes hacer un bizcocho (si sigues un orden estricto) o unas tortitas (si lo haces rápido y en porciones pequeñas).

En ingeniería del software, definimos la metodología como el marco de trabajo (*framework*) que nos dice **en qué orden ejecutar las fases** y **qué reglas seguir** para pasar de una a otra.

### 3.1. Modelos Predictivos: La Cascada (Waterfall)

Es el modelo clásico, nacido en los años 70 (Winston Royce). Se basa en una premisa sencilla pero rígida: **No pasas a la siguiente fase hasta que no has terminado y aprobado la anterior.**

1. Haces **toda** la toma de requisitos. Firmas los documentos.
2. Haces **todo** el diseño.
3. Escribes **todo** el código.
4. Pruebas **todo**.
5. Despliegas.

![Image of Waterfall model diagram](waterfall.jpg)

**Características:**

- **Lineal y Secuencial:** Como el agua en una cascada, una vez que cae al nivel inferior (de Diseño a Código), es muy difícil y costoso "subir" de nuevo.
- **Documentación exhaustiva:** Se genera mucha burocracia en cada salto de fase.

> [!CAUTION]
> **El problema del "Efecto Túnel":**
> En proyectos largos (ej. 1 año), el cliente define lo que quiere en Enero (Análisis) y no ve el resultado hasta Diciembre (Despliegue). Durante esos 12 meses (el túnel), no hay feedback. Si en Diciembre el cliente dice "esto no es lo que quería", el desastre es total y carísimo de arreglar. También es muy difícil anticipar todos los requisitos al principio, especialmente en proyectos innovadores o con alta incertidumbre, o si el entorno de negocio cambia rápidamente.

**¿Cuándo usar Cascada hoy en día?**

Aunque tiene mala fama, sigue siendo útil en escenarios muy concretos, porque ofrece control y predictibilidad:

- Proyectos con requisitos congelados que no van a cambiar (ej: software para un cohete o un dispositivo médico regulado).
- Proyectos donde el coste del error es vidas humanas o pérdidas millonarias inmediatas.

> [!NOTE]
> **Analogía Civil:** Si fueses a construir un puente, no querrías que el ingeniero civil usase metodologías ágiles y cambiase el diseño a mitad de obra porque "el cliente quiere algo diferente". Aquí la Cascada es la opción segura.

### 3.2. La Revolución Ágil (Modelos Adaptativos)

En los años 90 y 2000, con el auge de Internet, el mundo se aceleró. Los negocios ya no podían esperar un año a tener software. Los requisitos cambiaban cada semana. El modelo en Cascada empezó a fallar estrepitosamente.

Surgió entonces el **Manifiesto Ágil (2001)**, que cambió las reglas del juego priorizando:

- **Individuos e interacciones** sobre procesos y herramientas.
- **Software funcionando** sobre documentación extensiva.
- **Colaboración con el cliente** sobre negociación contractual.
- **Respuesta ante el cambio** sobre seguir un plan.

Las metodologías ágiles rompen el proyecto en "trocitos" pequeños y funcionales, repitiendo el ciclo completo (Análisis -> Diseño -> Código -> Pruebas) cada pocas semanas. A estos ciclos se les llama **Iteraciones** o **Sprints**.

![Image of Agile Scrum cycle diagram](agile_scrum.png)

### 3.3. Principales Metodologías Ágiles

Para el examen y vuestra vida laboral, debéis conocer principalmente dos:

#### 3.3.1. Scrum

Es el marco de trabajo más utilizado actualmente. Se basa en entregas parciales y regulares del producto final. Es el enfoque **iterativo e incremental** por excelencia y el estándar de facto en el desarrollo web y móvil.

- **Sprints:** Ciclos de trabajo fijos (normalmente de 2 a 4 semanas). Al final de cada Sprint, se debe entregar una parte del software *que funcione* (Incremento).
- **MVP (Producto Mínimo Viable):** Scrum permite lanzar una versión básica rápidamente y mejorarla continuamente con el feedback real de los usuarios, en lugar de esperar al final para lanzar el producto completo.
- **Roles:**
  - **Product Owner:** La voz del cliente. Prioriza qué se hace primero (gestiona el *Backlog*).
  - **Scrum Master:** El facilitador. Elimina obstáculos y protege al equipo de interrupciones.
  - **Development Team:** Vosotros. Equipo auto-organizado que construye el software.
- **Eventos:** Daily Scrum (reunión diaria de 15 min), Sprint Review (enseñar lo hecho al cliente) y Retrospectiva (ver qué podemos mejorar como equipo).

#### 3.3.2. Kanban

Originalmente creado por Toyota para la fabricación de coches, se adapta al software para visualizar el flujo de trabajo.

- **Flujo Continuo:** No hay Sprints fijos. Las tareas se van sacando del *Backlog* según la capacidad del equipo.
- **Tablero Visual:** Columnas de "Pendiente", "En Progreso", "En Pruebas", "Terminado".
- **WIP (Work In Progress):** Limita cuántas cosas se pueden hacer a la vez para evitar cuellos de botella.
- **Uso ideal:** Mantenimiento de software y equipos de soporte donde las tareas llegan de forma continua e impredecible (tickets de incidencias).

### 3.4. Comparativa: ¿Cascada o Ágil?

Como técnicos superiores, debéis saber elegir la herramienta adecuada. Aquí tenéis la "chuleta" definitiva:

| Característica | Cascada (Tradicional) | Ágil (Scrum/Kanban) |
| :--- | :--- | :--- |
| **Requisitos** | Claros, fijos y bien definidos desde el inicio. | Cambiantes, inciertos o poco claros. |
| **Entrega de valor** | Todo al final del proyecto (Big Bang). | Continua e incremental (cada 2-3 semanas). |
| **Cliente** | Participa al inicio y al final. | Participa continuamente durante el desarrollo. |
| **Coste del cambio** | Muy alto en etapas finales. | Bajo/Asumible (el sistema está pensado para cambiar). |
| **Escenario Ideal** | Sistemas críticos, construcción, hardware. | Startups, Apps móviles, Webs, SaaS. |

> [!TIP]
> No os preocupéis con memorizar todos los eventos de Scrum al detalle ahora mismo. Lo importante es que entendáis la **filosofía**: En Cascada *resistimos* el cambio (porque es caro); en Ágil *abrazamos* el cambio (porque nos da ventaja competitiva).

### 3.5. La Realidad Híbrida: Scrummerfall y Scrumban

En el mundo real, la pureza teórica es difícil de encontrar. Es muy probable que os encontréis con adaptaciones pragmáticas:

#### 3.5.1. Scrummerfall

Este modelo híbrido nace de la colisión entre equipos de desarrollo ágiles y grandes organizaciones cliente con procesos muy rígidos. Combina:

1. Una fase inicial de análisis y diseño muy definida y pesada (propia de **Waterfall**).
2. Fases de desarrollo y pruebas que se ejecutan en **Sprints** (al estilo **Scrum**).

Es un escenario muy común en grandes consultoras. Aunque el término "Scrummerfall" a veces se usa de forma peyorativa (implicando que "lo hacen mal"), es una realidad pragmática para acomodar contratos cerrados con metodologías de trabajo modernas.

#### 3.5.2. Scrumban

Mezcla la estructura de roles y reuniones de Scrum con la flexibilidad y el flujo de trabajo continuo de Kanban.

- En lugar de Sprints con una duración fija estricta, el equipo trabaja sobre un tablero Kanban.
- Ideal para proyectos con prioridades muy cambiantes o para equipos que combinan el desarrollo de nuevas funcionalidades con el mantenimiento y la resolución de incidencias urgentes (donde un Sprint de 2 semanas es demasiado rígido).

---

### 3.6. Actividad de Reflexión

Estas preguntas no tienen una única respuesta correcta, pero son situaciones reales que os encontraréis en la entrevista de trabajo o en el primer mes de empleo. Pensad sobre ellas:

> 1. **El conflicto del Presupuesto:** Si una gran empresa os contrata para desarrollar una App con un presupuesto cerrado (ej: 20.000€), ¿qué conflicto surge al aplicar Agile? (Pista: Agile implica alcance variable). ¿Cómo convenceríais al cliente de que Agile es mejor que la falsa seguridad de un presupuesto cerrado?
> 2. **El "Scope Creep" (Alcance no controlado):** ¿Cómo evita el equipo que el cliente añada funcionalidades sin control en cada Sprint ("ya que estáis, ponedme esto también"), desvirtuando el proyecto y los plazos?
> 3. **Tensión Híbrida:** Un equipo intenta trabajar con Sprints (Agile) dentro de una organización que exige un plan cerrado con meses de antelación (Waterfall). ¿Qué tensiones creéis que surgirán entre los desarrolladores y la gerencia?

---

## Referencias y bibliografía complementaria

- UML y Patrones - Craig Larman
- [Playlist: Curso UML. Introducción. Vídeo 1](https://www.youtube.com/watch?v=KY81igoV8W0&list=PLU8oAlHdN5BmmxXT0C2HO0bLRHZFWKbhH). Especialmente interesantes los vídeos 1 y 2 de la playlist para este tema.
-[Vídeo: Qué son las metodologías tradicionales en el desarrollo de software](https://www.youtube.com/watch?v=i8CPD1dW88k)
- [Vídeo: TODOS los Marcos y Metodologías explicados en 10 minutos: Scrum, Kanban, Lean, Agile, XP, FDD...](https://www.youtube.com/watch?v=Smf2BKwiBmM)
- La web del profesor **Fernando Bazal** en lo relacionado con la ingeniería del software [https://software-engineering.ikor.org/courseware/](https://software-engineering.ikor.org/courseware/) contiene muchos recursos de una calidad técnica excepcional y en castellano. Recomendaros en particular [https://drive.google.com/file/d/15mD4hdozXAkkz2TxqER05ILy-XTyEs9H/view](https://drive.google.com/file/d/15mD4hdozXAkkz2TxqER05ILy-XTyEs9H/view), si bien en la segunda parte se centra más en el tema de las bases de datos no deja de ser un recurso muy valioso para esta unidad.
- [Agile Manifesto](https://agilemanifesto.org/)
- [Scrum Guide](https://scrumguides.org/scrum-guide.html)
- [Kanban Guide](https://kanban.university/kanban-guide/)
- [The Mythical Man-Month - Frederick P. Brooks](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)

### Notas personales

Se podría incorporar el tema de las herramientas de acuerdo al material de otros cursos.
